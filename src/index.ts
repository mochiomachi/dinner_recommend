import { RecommendationAgent, UserRequest, RecommendationContext } from './agent';
import { PROMPTS, renderPrompt, PromptVariables, loadAndRenderMarkdownPrompt } from './prompts/index';

export interface Env {
	DB: D1Database;
	OPENAI_API_KEY: string;
	LINE_CHANNEL_SECRET: string;
	LINE_CHANNEL_ACCESS_TOKEN: string;
	OPENWEATHER_API_KEY: string;
}

export default {
	async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
		const url = new URL(request.url);
		
		// D1 Database Test Endpoint
		if (request.method === 'GET' && url.pathname === '/db-test') {
			console.log('=== D1 Database Test ===');
			console.log('env.DB:', env.DB);
			console.log('typeof env.DB:', typeof env.DB);
			console.log('env.DB === null:', env.DB === null);
			console.log('env.DB === undefined:', env.DB === undefined);
			
			if (env.DB) {
				try {
					const result = await env.DB.prepare('SELECT 1 as test, "DB Connection Success" as message').first();
					return new Response(JSON.stringify(result, null, 2), {
						headers: { 'Content-Type': 'application/json' }
					});
				} catch (error) {
					return new Response(`DB Error: ${error}`, { status: 500 });
				}
			} else {
				return new Response('‚ùå env.DB is null or undefined', { status: 500 });
			}
		}
		
		if (request.method === 'POST' && url.pathname === '/webhook') {
			console.log('Webhook called!');
			return handleLineWebhook(request, env, ctx);
		}
		
		if (request.method === 'GET' && url.pathname === '/health') {
			return new Response('OK', { status: 200 });
		}
		
		// „Éó„É≠„É≥„Éó„Éà„ÉÜ„Çπ„ÉàÁî®„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
		if (request.method === 'POST' && url.pathname === '/test-prompt') {
			return await handlePromptTest(request, env);
		}
		
		// „Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥„Éó„É≠„É≥„Éó„Éà„ÉÜ„Çπ„ÉàÁî®„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
		if (request.method === 'POST' && url.pathname === '/test-markdown-prompt') {
			return await handleMarkdownPromptTest(request, env);
		}
		
		// OpenAI APIÂÆüË°å„ÉÜ„Çπ„ÉàÁî®„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
		if (request.method === 'POST' && url.pathname === '/test-openai-output') {
			return await handleOpenAIOutputTest(request, env);
		}
		
		// CronÊ©üËÉΩ„ÉÜ„Çπ„ÉàÁî®„Ç®„É≥„Éâ„Éù„Ç§„É≥„ÉàÔºà„É≠„Éº„Ç´„É´ÈñãÁô∫Áî®Ôºâ
		if (request.method === 'POST' && url.pathname === '/test-cron') {
			console.log('üïê Manual cron trigger test started');
			ctx.waitUntil(sendDailyRecommendations(env));
			return new Response('Cron test triggered - check logs for execution details', { 
				status: 200,
				headers: { 'Content-Type': 'text/plain' }
			});
		}
		
		// Áí∞Â¢ÉÂ§âÊï∞Á¢∫Ë™çÁî®„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
		if (request.method === 'GET' && url.pathname === '/test-env') {
			const envCheck = {
				hasOpenAI: !!env.OPENAI_API_KEY,
				openAIKeyLength: env.OPENAI_API_KEY?.length || 0,
				openAIKeyPrefix: env.OPENAI_API_KEY?.substring(0, 8) || 'not set',
				hasLineSecret: !!env.LINE_CHANNEL_SECRET,
				hasLineToken: !!env.LINE_CHANNEL_ACCESS_TOKEN,
				hasWeatherKey: !!env.OPENWEATHER_API_KEY
			};
			return new Response(JSON.stringify(envCheck, null, 2), {
				headers: { 'Content-Type': 'application/json' }
			});
		}
		
		// DB Recommendations Debug Endpoint
		if (request.method === 'GET' && url.pathname === '/debug-recommendations') {
			console.log('=== Debug Recommendations ===');
			try {
				// ÊúÄÊñ∞„ÅÆ„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÂèñÂæó
				const latestSessionResult = await env.DB.prepare(`
					SELECT session_id, user_id, created_at 
					FROM user_sessions 
					ORDER BY created_at DESC 
					LIMIT 1
				`).first();
				
				if (!latestSessionResult) {
					return new Response('No sessions found', { status: 404 });
				}
				
				console.log('Latest session:', latestSessionResult);
				
				// „Åù„ÅÆ„Çª„ÉÉ„Ç∑„Éß„É≥„ÅÆÊé®Ëñ¶„Éá„Éº„Çø„ÇíÂèñÂæó
				const recommendationsResult = await env.DB.prepare(`
					SELECT dish_name, recommendation_order, recommended_at 
					FROM recommended_dishes 
					WHERE session_id = ? 
					ORDER BY recommendation_order ASC
				`).bind(latestSessionResult.session_id).all();
				
				console.log('Recommendations:', recommendationsResult);
				
				return new Response(JSON.stringify({
					session: latestSessionResult,
					recommendations: recommendationsResult.results || [],
					expected: "1Áï™ÁõÆ„Å´„ÄåÊ∏©„Åã„ÅÑË±öÊ±Å„Äç„Åå„ÅÇ„Çã„ÅÆ„ÅåÊ≠£Â∏∏"
				}, null, 2), {
					headers: { 'Content-Type': 'application/json' }
				});
				
			} catch (error) {
				console.error('Debug recommendations error:', error);
				return new Response(`Debug failed: ${error}`, { status: 500 });
			}
		}

		// Users table debug endpoint
		if (request.method === 'GET' && url.pathname === '/debug-users') {
			console.log('=== Debug Users ===');
			try {
				const allUsers = await env.DB.prepare('SELECT id, invited, allergies, dislikes, created_at FROM users').all();
				const invitedUsers = await env.DB.prepare('SELECT id, invited, allergies, dislikes, created_at FROM users WHERE invited = 1').all();
				
				return new Response(JSON.stringify({
					totalUsers: allUsers.results?.length || 0,
					invitedUsers: invitedUsers.results?.length || 0,
					allUsers: allUsers.results,
					invitedOnly: invitedUsers.results
				}, null, 2), {
					headers: { 'Content-Type': 'application/json' }
				});
			} catch (error) {
				console.error('Debug users error:', error);
				return new Response(`Debug failed: ${error}`, { status: 500 });
			}
		}

		// D1 Meals Table Test Endpoint
		if (request.method === 'GET' && url.pathname === '/d1-meals-test') {
			console.log('=== D1 Meals Table Test ===');
			try {
				const userId = 'U8908fdb52a3705527eed6b130b62fc0c'; // Test user
				
				// Test 1: Simple count query with timeout
				console.log('Test 1: Simple COUNT query with timeout...');
				const countPromise = env.DB.prepare('SELECT COUNT(*) as count FROM meals WHERE user_id = ?').bind(userId).first();
				const countTimeout = new Promise((_, reject) => 
					setTimeout(() => reject(new Error('Count query timeout after 5s')), 5000)
				);
				
				const countResult = await Promise.race([countPromise, countTimeout]);
				console.log('Count result:', countResult);
				
				// Test 2: Simple SELECT query with LIMIT and timeout
				console.log('Test 2: Simple SELECT with LIMIT...');
				const selectPromise = env.DB.prepare('SELECT dish, rating FROM meals WHERE user_id = ? LIMIT 3').bind(userId).all();
				const selectTimeout = new Promise((_, reject) => 
					setTimeout(() => reject(new Error('Select query timeout after 5s')), 5000)
				);
				
				const selectResult = await Promise.race([selectPromise, selectTimeout]);
				console.log('Select result:', selectResult);
				
				// Test 3: Date-filtered query (the problematic one)
				console.log('Test 3: Date-filtered query...');
				const datePromise = env.DB.prepare(`
					SELECT dish, rating FROM meals 
					WHERE user_id = ? AND ate_date >= date('now', '-14 days')
					LIMIT 5
				`).bind(userId).all();
				const dateTimeout = new Promise((_, reject) => 
					setTimeout(() => reject(new Error('Date query timeout after 8s')), 8000)
				);
				
				const dateResult = await Promise.race([datePromise, dateTimeout]);
				console.log('Date query result:', dateResult);
				
				return new Response(JSON.stringify({
					status: 'success',
					count: countResult,
					select: selectResult,
					dateQuery: dateResult
				}, null, 2), {
					headers: { 'Content-Type': 'application/json' }
				});
				
			} catch (error) {
				console.error('D1 meals test error:', error);
				return new Response(`D1 Meals Test Failed: ${error}`, { status: 500 });
			}
		}
		
		// OpenAI API Test Endpoint
		if (request.method === 'GET' && url.pathname === '/openai-test') {
			console.log('=== OpenAI API Test ===');
			try {
				console.log('Testing OpenAI API key...');
				
				const testPromise = fetch('https://api.openai.com/v1/chat/completions', {
					method: 'POST',
					headers: {
						'Authorization': `Bearer ${env.OPENAI_API_KEY}`,
						'Content-Type': 'application/json',
					},
					body: JSON.stringify({
						model: 'gpt-4o-mini',
						messages: [{ role: 'user', content: 'Hello' }],
						max_tokens: 5,
					}),
				});
				
				const timeoutPromise = new Promise((_, reject) => 
					setTimeout(() => reject(new Error('Timeout after 10s')), 10000)
				);
				
				const response = await Promise.race([testPromise, timeoutPromise]) as Response;
				
				if (!response.ok) {
					const errorText = await response.text();
					return new Response(`OpenAI API Error: ${response.status} - ${errorText}`, { status: 500 });
				}
				
				const data = await response.json() as any;
				return new Response(JSON.stringify({
					status: 'success',
					response_status: response.status,
					model: data.model,
					content: data.choices?.[0]?.message?.content || 'No content'
				}, null, 2), {
					headers: { 'Content-Type': 'application/json' }
				});
				
			} catch (error) {
				console.error('OpenAI test error:', error);
				return new Response(`OpenAI Test Failed: ${error}`, { status: 500 });
			}
		}
		
		return new Response('Not Found', { status: 404 });
	},

	async scheduled(_controller: ScheduledController, env: Env, ctx: ExecutionContext): Promise<void> {
		// Daily recommendation push at 14:00 JST
		ctx.waitUntil(sendDailyRecommendations(env));
	}
} satisfies ExportedHandler<Env>;

/**
 * „Éó„É≠„É≥„Éó„Éà„ÉÜ„Çπ„ÉàÁî®„Éè„É≥„Éâ„É©„Éº
 */
async function handlePromptTest(request: Request, env: Env): Promise<Response> {
	try {
		const body = await request.json() as any;
		const { testType, ...params } = body;
		
		const agent = new RecommendationAgent(env.DB, env.OPENAI_API_KEY, PROMPTS, renderPrompt);
		
		if (testType === 'userRequest') {
			const result = analyzeRequestTypeFromMessage(params.message || '„Åä„Åô„Åô„ÇÅ„Åó„Å¶');
			return new Response(JSON.stringify(result, null, 2), {
				headers: { 'Content-Type': 'application/json' }
			});
		}
		
		if (testType === 'recommendation') {
			const mockContext = {
				user: {
					id: 'test-user',
					allergies: params.allergies || '„Å™„Åó',
					dislikes: params.dislikes || '„Å™„Åó'
				},
				recentMeals: params.recentMeals || [
					{ dish: '„Ç´„É¨„Éº„É©„Ç§„Çπ', rating: 4, mood: 'Ê∫ÄË∂≥', ate_date: '2025-06-06' }
				],
				previousRecommendations: [],
				userRequest: {
					type: params.requestType || 'general',
					originalMessage: params.message || '„Åä„Åô„Åô„ÇÅ„Åó„Å¶',
					timestamp: new Date()
				},
				weather: params.weather || { temp: 20, description: 'Êõá„Çä' },
				avoidanceStrategy: {
					avoidIngredients: params.avoidIngredients || [],
					avoidGenres: params.avoidGenres || [],
					avoidCookingMethods: params.avoidCookingMethods || [],
					reason: '„ÉÜ„Çπ„ÉàÁî®'
				}
			};
			
			const result = await agent.generateDiverseRecommendations(mockContext);
			return new Response(JSON.stringify(result, null, 2), {
				headers: { 'Content-Type': 'application/json' }
			});
		}
		
		return new Response('Invalid testType. Use "userRequest" or "recommendation"', { 
			status: 400 
		});
		
	} catch (error) {
		return new Response(`Prompt test error: ${error}`, { status: 500 });
	}
}

async function handleOpenAIOutputTest(request: Request, env: Env): Promise<Response> {
	try {
		const body = await request.json() as any;
		const { promptType, ...variables } = body;
		
		// „Éá„Éï„Ç©„É´„ÉàÂÄ§„ÇíË®≠ÂÆö
		const defaultVariables = {
			recentMeals: variables.recentMeals || '„Ç´„É¨„Éº„É©„Ç§„Çπ„ÄÅ„Éè„É≥„Éê„Éº„Ç∞„ÄÅÁÑº„ÅçÈ≠ö',
			preferredDishes: variables.preferredDishes || 'ÂîêÊèö„Åí„ÄÅËÇâ„Åò„ÇÉ„Åå',
			allergies: variables.allergies || '„Å™„Åó',
			dislikes: variables.dislikes || '„Å™„Åó',
			temperature: variables.temperature || '15',
			weather: variables.weather || 'ÂÜ¨„ÅÆÂ≠£ÁØÄ„ÄÅÂØí„ÅÑÊó•ÔºàÊ∏©„Åã„ÅÑÊñôÁêÜ„ÉªÁÖÆËæº„ÅøÊñôÁêÜ„Åå„Åä„Åô„Åô„ÇÅÔºâ„ÄÅÈõ®„ÅÆÊó•„ÅßÊ∏©„Åã„ÅÑÂÆ§ÂÜÖÊñôÁêÜ„ÅåËâØ„ÅÑ',
			previousRecommendations: variables.previousRecommendations || 'ËÇâ„Åò„ÇÉ„ÅåÔºàÂíåÈ£ü„Éª„Åò„ÇÉ„Åå„ÅÑ„ÇÇ„ÉªÁÖÆËæº„ÅøÔºâ„ÄÅ„Éè„É≥„Éê„Éº„Ç∞ÔºàÊ¥ãÈ£ü„Éª„Å≤„ÅçËÇâ„ÉªÁÑº„ÅçÔºâ„ÄÅÈ∫ªÂ©ÜË±ÜËÖêÔºà‰∏≠ËèØ„ÉªË±ÜËÖê„ÉªÁÇí„ÇÅÔºâ',
			requestType: variables.requestType || 'diverse',
			originalMessage: variables.originalMessage || '‰ªñ„ÅÆÊèêÊ°à„ÇÇË¶ã„Åü„ÅÑ',
			avoidIngredients: variables.avoidIngredients || '„Åò„ÇÉ„Åå„ÅÑ„ÇÇ„ÄÅ„Å≤„ÅçËÇâ„ÄÅË±ÜËÖê',
			avoidGenres: variables.avoidGenres || 'ÂíåÈ£ü„ÄÅÊ¥ãÈ£ü„ÄÅ‰∏≠ËèØ',
			avoidCookingMethods: variables.avoidCookingMethods || 'ÁÖÆËæº„Åø„ÄÅÁÑº„Åç„ÄÅÁÇí„ÇÅ'
		};
		
		let promptName;
		if (promptType === 'initial') {
			promptName = 'initial-recommendation';
		} else if (promptType === 're-recommendation') {
			promptName = 're-recommendation';
		} else {
			return new Response('Invalid promptType. Use "initial" or "re-recommendation"', { 
				status: 400 
			});
		}
		
		// „Éó„É≠„É≥„Éó„ÉàÁîüÊàê
		const renderedPrompt = await loadAndRenderMarkdownPrompt(promptName, defaultVariables);
		
		// OpenAI APIÂëº„Å≥Âá∫„Åó
		console.log(`ü§ñ Testing OpenAI API with ${promptType} prompt...`);
		const response = await fetch('https://api.openai.com/v1/chat/completions', {
			method: 'POST',
			headers: {
				'Authorization': `Bearer ${env.OPENAI_API_KEY}`,
				'Content-Type': 'application/json',
			},
			body: JSON.stringify({
				model: 'gpt-4o-mini',
				messages: [{ role: 'user', content: renderedPrompt }],
				max_tokens: 1000,
				temperature: 0.7,
			}),
		});

		if (!response.ok) {
			throw new Error(`OpenAI API error: ${response.status}`);
		}

		const data = await response.json() as any;
		const openaiOutput = data.choices[0].message.content;
		
		console.log(`‚úÖ OpenAI API response received`);
		console.log(`üìù Output length: ${openaiOutput.length} characters`);
		
		return new Response(JSON.stringify({
			promptType,
			variables: defaultVariables,
			renderedPrompt,
			openaiOutput,
			usage: data.usage
		}, null, 2), {
			headers: { 'Content-Type': 'application/json' }
		});
		
	} catch (error) {
		console.error(`‚ùå OpenAI output test error:`, error);
		return new Response(`OpenAI output test error: ${error}`, { status: 500 });
	}
}

async function handleMarkdownPromptTest(request: Request, env: Env): Promise<Response> {
	try {
		const body = await request.json() as any;
		const { promptType, ...variables } = body;
		
		// „Éá„Éï„Ç©„É´„ÉàÂÄ§„ÇíË®≠ÂÆö
		const defaultVariables = {
			recentMeals: variables.recentMeals || '„Ç´„É¨„Éº„É©„Ç§„Çπ„ÄÅ„Éè„É≥„Éê„Éº„Ç∞„ÄÅÁÑº„ÅçÈ≠ö',
			preferredDishes: variables.preferredDishes || 'ÂîêÊèö„Åí„ÄÅËÇâ„Åò„ÇÉ„Åå',
			allergies: variables.allergies || '„Å™„Åó',
			dislikes: variables.dislikes || '„Å™„Åó',
			temperature: variables.temperature || '20',
			weather: variables.weather || 'Êõá„Çä„ÄÅÊ∂º„Åó„ÅÑÈ¢®',
			previousRecommendations: variables.previousRecommendations || 'ËÇâ„Åò„ÇÉ„ÅåÔºàÂíåÈ£ü„Éª„Åò„ÇÉ„Åå„ÅÑ„ÇÇ„ÉªÁÖÆËæº„ÅøÔºâ„ÄÅ„Éè„É≥„Éê„Éº„Ç∞ÔºàÊ¥ãÈ£ü„Éª„Å≤„ÅçËÇâ„ÉªÁÑº„ÅçÔºâ„ÄÅÈ∫ªÂ©ÜË±ÜËÖêÔºà‰∏≠ËèØ„ÉªË±ÜËÖê„ÉªÁÇí„ÇÅÔºâ',
			requestType: variables.requestType || 'diverse',
			originalMessage: variables.originalMessage || '‰ªñ„ÅÆÊèêÊ°à„ÇÇË¶ã„Åü„ÅÑ',
			avoidIngredients: variables.avoidIngredients || '„Åò„ÇÉ„Åå„ÅÑ„ÇÇ„ÄÅ„Å≤„ÅçËÇâ„ÄÅË±ÜËÖê',
			avoidGenres: variables.avoidGenres || 'ÂíåÈ£ü„ÄÅÊ¥ãÈ£ü„ÄÅ‰∏≠ËèØ',
			avoidCookingMethods: variables.avoidCookingMethods || 'ÁÖÆËæº„Åø„ÄÅÁÑº„Åç„ÄÅÁÇí„ÇÅ'
		};
		
		let promptName;
		if (promptType === 'initial') {
			promptName = 'initial-recommendation';
		} else if (promptType === 're-recommendation') {
			promptName = 're-recommendation';
		} else {
			return new Response('Invalid promptType. Use "initial" or "re-recommendation"', { 
				status: 400 
			});
		}
		
		const renderedPrompt = await loadAndRenderMarkdownPrompt(promptName, defaultVariables);
		
		return new Response(JSON.stringify({
			promptType,
			variables: defaultVariables,
			renderedPrompt
		}, null, 2), {
			headers: { 'Content-Type': 'application/json' }
		});
		
	} catch (error) {
		return new Response(`Markdown prompt test error: ${error}`, { status: 500 });
	}
}

async function handleLineWebhook(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
	try {
		const body = await request.text();
		const signature = request.headers.get('x-line-signature');
		
		console.log('Body received:', body);
		console.log('Signature:', signature);
		
		// Verify LINE signature
		if (!signature || !(await verifyLineSignature(body, signature, env.LINE_CHANNEL_SECRET))) {
			console.log('Signature verification failed');
			return new Response('Unauthorized', { status: 401 });
		}
		
		const data = JSON.parse(body);
		console.log('Parsed data:', JSON.stringify(data));
		
		for (const event of data.events) {
			console.log('Processing event:', JSON.stringify(event));
			if (event.type === 'message' && event.message.type === 'text') {
				await handleTextMessage(event, env, ctx);
			}
		}
		
		return new Response('OK', { status: 200 });
	} catch (error) {
		console.error('Webhook error:', error);
		return new Response('Internal Server Error', { status: 500 });
	}
}

async function handleTextMessage(event: any, env: Env, ctx: ExecutionContext): Promise<void> {
	const userId = event.source.userId;
	const messageText = event.message.text;
	const replyToken = event.replyToken;
	
	// Check if user is invited/registered, or handle invitation
	let user = await getUser(userId, env);
	
	if (!user) {
		// Create new user
		await createUser(userId, env);
		await sendLineReply(replyToken, 'üéâ Â§ïÈ£ü„É¨„Ç≥„É°„É≥„ÉâBot„Å∏„Çà„ÅÜ„Åì„ÅùÔºÅ\n\nÊãõÂæÖ„Ç≥„Éº„Éâ„ÇíÂÖ•Âäõ„Åô„Çã„Åã„ÄÅ/setup„Ç≥„Éû„É≥„Éâ„ÅßË®≠ÂÆö„ÇíÈñãÂßã„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ', env);
		return;
	}
	
	if (!user.invited) {
		// Handle invitation codes
		if (messageText.startsWith('INVITE-') || messageText === 'family2024') {
			await inviteUser(userId, env);
			await sendLineReply(replyToken, '‚úÖ ÊãõÂæÖ„Ç≥„Éº„Éâ„ÅåÁ¢∫Ë™ç„Åï„Çå„Åæ„Åó„ÅüÔºÅ\n/setup„Ç≥„Éû„É≥„Éâ„ÅßË®≠ÂÆö„ÇíÈñãÂßã„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ', env);
			return;
		} else {
			await sendLineReply(replyToken, 'ÊãõÂæÖ„Ç≥„Éº„Éâ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ', env);
			return;
		}
	}
	
	if (messageText.startsWith('/setup')) {
		await handleSetupCommand(replyToken, env);
	} else if (messageText.includes('„Ç¢„É¨„É´„ÇÆ„Éº') && (messageText.includes('Êµ∑Áî£Áâ©') || messageText.includes('È≠ö') || messageText.includes('„Ç¢„Éã„Çµ„Ç≠„Çπ'))) {
		await handleSeafoodAllergyUpdate(userId, replyToken, env);
	} else if (messageText.includes('Â´å„ÅÑ„Å™È£üÊùê') || (messageText.includes('Â´å„ÅÑ') && (messageText.includes('È£üÊùê') || messageText.includes('ÈáéËèú') || messageText.includes('Ë±Ü')))) {
		await handleDislikedFoodsUpdate(userId, replyToken, messageText, env);
	} else if (messageText.includes('‚≠ê') || messageText.includes('‚òÖ')) {
		await handleMealInput(userId, replyToken, messageText, env);
	} else if (messageText.match(/^[1-3]$/) || messageText.includes('ÈÅ∏„Å∂') || messageText.includes('„Åì„Çå')) {
		await handleRecipeRequest(userId, replyToken, messageText, env, ctx);
	} else if (messageText.includes('„Åä„Åô„Åô„ÇÅ') || messageText.includes('„É¨„Ç≥„É°„É≥„Éâ') || messageText.includes('‰ªäÊó•„ÅÆÂ§ïÈ£ü')) {
		// ÂàùÂõûÊé®Ëñ¶Â∞ÇÁî®Âá¶ÁêÜ
		await handleInitialRecommendation(userId, replyToken, messageText, user, env, ctx);
	} else if (messageText.includes('‰ªñ„ÅÆ') || messageText.includes('ÈÅï„ÅÜ') || messageText.includes('Âà•„ÅÆ') || 
			   messageText.includes('„ÅÇ„Å£„Åï„Çä') || messageText.includes('„Åï„Å£„Å±„Çä') || 
			   messageText.includes('„Åå„Å£„Å§„Çä') || messageText.includes('„Éú„É™„É•„Éº„É†') || messageText.includes('ÊèêÊ°à') ||
			   messageText.includes('Á≥ª') || messageText.includes('ÊñôÁêÜ„ÅåËâØ„ÅÑ')) {
		// ÂÜçÊèêÊ°àÂ∞ÇÁî®Âá¶ÁêÜ
		await handleUnifiedRecommendationRequest(userId, replyToken, messageText, user, env, ctx);
	} else if (messageText.includes('Ê∫ÄË∂≥') || messageText.includes('„ÅÇ„Çä„Åå„Å®„ÅÜ') || messageText.includes('„ÅÑ„ÅÑ„Åß„Åô„Å≠')) {
		// Ê∫ÄË∂≥„É°„ÉÉ„Çª„Éº„Ç∏„Å∏„ÅÆÂøúÁ≠î
		await sendLineReply(replyToken, 'üòä „ÅÇ„Çä„Åå„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„ÅôÔºÅ„ÅäÊñôÁêÜ„ÇíÊ•Ω„Åó„Çì„Åß„Åè„Å†„Åï„ÅÑ„Å≠„ÄÇ\n\nÈ£ü‰∫ã„ÅÆË®òÈå≤„ÅØ ‚≠ê „ÅßË©ï‰æ°„Å®‰∏ÄÁ∑í„Å´ÊäïÁ®ø„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ', env);
	} else if (messageText.includes('‰Ωø„ÅÑÊñπ') || messageText.includes('„Éò„É´„Éó') || messageText.toLowerCase().includes('help')) {
		// „Éò„É´„Éó„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆË°®Á§∫
		await handleHelpRequest(replyToken, env);
	} else {
		// ‰∏ÄËà¨„É°„ÉÉ„Çª„Éº„Ç∏Âá¶ÁêÜÔºàÊé®Ëñ¶Ë¶ÅÊ±Ç„Åß„Å™„ÅÑÂ†¥ÂêàÔºâ
		await handleGeneralMessage(replyToken, messageText, env);
	}
}

async function handleHelpRequest(replyToken: string, env: Env): Promise<void> {
	const helpMessage = `ü§ñ **Â§ïÈ£ü„É¨„Ç≥„É°„É≥„ÉâBot ‰Ωø„ÅÑÊñπ„Ç¨„Ç§„Éâ**

üìù **Âü∫Êú¨Ê©üËÉΩÔºö**
‚Ä¢ „Äå„Åä„Åô„Åô„ÇÅÊïô„Åà„Å¶„Äç‚Üí ‰ªäÊó•„ÅÆÂ§ïÈ£ü„ÇíÊèêÊ°à
‚Ä¢ „Äå‰ªñ„ÅÆÊèêÊ°à„Äç‚Üí Âà•„ÅÆÊñôÁêÜ„ÇíÊèêÊ°à  
‚Ä¢ „Äå„Åï„Å£„Å±„ÇäÁ≥ª„Äç‚Üí „ÅÇ„Å£„Åï„ÇäÊñôÁêÜ„ÇíÊèêÊ°à
‚Ä¢ „Äå„Åå„Å£„Å§„ÇäÁ≥ª„Äç‚Üí „Éú„É™„É•„Éº„É†ÊñôÁêÜ„ÇíÊèêÊ°à

üç≥ **„É¨„Ç∑„ÉîÊ©üËÉΩÔºö**
‚Ä¢ Êï∞Â≠ó„Äå1„Äç„Äå2„Äç„Äå3„Äç‚Üí ÈÅ∏Êäû„Åó„ÅüÊñôÁêÜ„ÅÆ„É¨„Ç∑„ÉîË°®Á§∫

üìä **È£ü‰∫ãË®òÈå≤Ôºö**
‚Ä¢ „Äå‚≠ê3 „Éè„É≥„Éê„Éº„Ç∞ÁæéÂë≥„Åó„Åã„Å£„Åü„Äç‚Üí Ë©ï‰æ°‰ªò„Åç„ÅßË®òÈå≤
‚Ä¢ ‚≠ê„ÅÆÊï∞„ÅßÊ∫ÄË∂≥Â∫¶„ÇíË°®ÁèæÔºà1-5ÂÄãÔºâ

‚öôÔ∏è **Ë®≠ÂÆöÊ©üËÉΩÔºö**
‚Ä¢ „Äå/setup„Äç‚Üí ÂàùÊúüË®≠ÂÆöÈñãÂßã
‚Ä¢ „Äå„Ç¢„É¨„É´„ÇÆ„Éº Êµ∑Áî£Áâ©„Äç‚Üí Êµ∑Áî£Áâ©„Ç¢„É¨„É´„ÇÆ„ÉºÁôªÈå≤
‚Ä¢ „ÄåÂ´å„ÅÑ„Å™È£üÊùê „Åù„ÇâË±Ü„ÄÅ„Ç§„É≥„Ç≤„É≥Ë±Ü„Äç‚Üí Â´å„ÅÑ„Å™È£üÊùêÁôªÈå≤

üí° **„Åù„ÅÆ‰ªñÔºö**
‚Ä¢ ÊØéÊó•14ÊôÇ„Å´Ëá™Âãï„Åß„Åä„Åô„Åô„ÇÅÊñôÁêÜ„ÇíÈÖç‰ø°
‚Ä¢ Â§©Ê∞ó„ÇÑÈÅéÂéª„ÅÆÈ£ü‰∫ã„ÇíËÄÉÊÖÆ„Åó„ÅüÊèêÊ°à

‰Ωï„ÅãË≥™Âïè„Åå„ÅÇ„Çå„Å∞„Äå‰Ωø„ÅÑÊñπ„Äç„Å®ÈÄÅ‰ø°„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ`;

	await sendLineReply(replyToken, helpMessage, env);
}

async function handleDislikedFoodsUpdate(userId: string, replyToken: string, messageText: string, env: Env): Promise<void> {
	try {
		// Â´å„ÅÑ„Å™È£üÊùê„Çí„É°„ÉÉ„Çª„Éº„Ç∏„Åã„ÇâÊäΩÂá∫
		let dislikedFoods = '';
		
		// „Éë„Çø„Éº„É≥1: "Â´å„ÅÑ„Å™È£üÊùê „Åù„ÇâË±Ü„ÄÅ„Ç§„É≥„Ç≤„É≥Ë±Ü"
		const pattern1 = messageText.match(/Â´å„ÅÑ„Å™È£üÊùê[Ôºö:\s]*(.+)/);
		if (pattern1) {
			dislikedFoods = pattern1[1].trim();
		} else {
			// „Éë„Çø„Éº„É≥2: "Â´å„ÅÑ „Åù„ÇâË±Ü„ÄÅ„Ç§„É≥„Ç≤„É≥Ë±Ü"
			const pattern2 = messageText.match(/Â´å„ÅÑ[Ôºö:\s]*(.+)/);
			if (pattern2) {
				dislikedFoods = pattern2[1].trim();
			}
		}
		
		if (!dislikedFoods) {
			await sendLineReply(replyToken, 
				'Â´å„ÅÑ„Å™È£üÊùê„ÇíÊïô„Åà„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n\n‰æãÔºö„ÄåÂ´å„ÅÑ„Å™È£üÊùê „Åù„ÇâË±Ü„ÄÅ„Ç§„É≥„Ç≤„É≥Ë±Ü„Äç', 
				env
			);
			return;
		}
		
		// „Éá„Éº„Çø„Éô„Éº„Çπ„Å´‰øùÂ≠ò
		await env.DB.prepare(`
			UPDATE users SET dislikes = ? 
			WHERE id = ?
		`).bind(dislikedFoods, userId).run();
		
		console.log(`‚úÖ Disliked foods updated for user: ${userId} - ${dislikedFoods}`);
		
		await sendLineReply(replyToken, 
			`üö´ Â´å„ÅÑ„Å™È£üÊùêÊÉÖÂ†±„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„ÅüÔºÅ\n\nÁôªÈå≤ÂÜÖÂÆπ: ${dislikedFoods}\n\n‰ªäÂæå„ÅÆÊé®Ëñ¶„Åß„ÅØ„Åì„Çå„Çâ„ÅÆÈ£üÊùê„ÇíÂê´„ÇÄÊñôÁêÜ„ÅØÈô§Â§ñ„Åï„Çå„Åæ„Åô„ÄÇ\n\nÂ§âÊõ¥„Åó„Åü„ÅÑÂ†¥Âêà„ÅØÂÜçÂ∫¶„ÄåÂ´å„ÅÑ„Å™È£üÊùê ‚óã‚óã„ÄÅ‚ñ≥‚ñ≥„Äç„Å®ÈÄÅ‰ø°„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`, 
			env
		);
	} catch (error) {
		console.error('Failed to update disliked foods:', error);
		await sendLineReply(replyToken, 'Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„ÄÇÂ´å„ÅÑ„Å™È£üÊùêÊÉÖÂ†±„ÅÆÊõ¥Êñ∞„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ', env);
	}
}

async function handleSeafoodAllergyUpdate(userId: string, replyToken: string, env: Env): Promise<void> {
	try {
		// Êµ∑Áî£Áâ©„Ç¢„É¨„É´„ÇÆ„Éº„ÇíË®≠ÂÆö
		await env.DB.prepare(`
			UPDATE users SET allergies = 'Êµ∑Áî£Áâ©ÂÖ®Ëà¨ÔºàÈ≠ö„ÄÅÊµ∑ËÄÅ„ÄÅËüπ„ÄÅË≤ùÈ°û„ÄÅÊµ∑ËóªÈ°ûÔºâ' 
			WHERE id = ?
		`).bind(userId).run();
		
		console.log(`‚úÖ Seafood allergy updated for user: ${userId}`);
		
		await sendLineReply(replyToken, 
			'üö´ Êµ∑Áî£Áâ©„Ç¢„É¨„É´„ÇÆ„ÉºÊÉÖÂ†±„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„ÅüÔºÅ\n\n‰ªäÂæå„ÅÆÊé®Ëñ¶„Åß„ÅØÈ≠ö„ÄÅÊµ∑ËÄÅ„ÄÅËüπ„ÄÅË≤ùÈ°û„ÄÅÊµ∑ËóªÈ°û„ÇíÂê´„ÇÄÊñôÁêÜ„ÅØÈô§Â§ñ„Åï„Çå„Åæ„Åô„ÄÇ\n\nÂ§âÊõ¥„Åó„Åü„ÅÑÂ†¥Âêà„ÅØÂÜçÂ∫¶„Äå„Ç¢„É¨„É´„ÇÆ„Éº Êµ∑Áî£Áâ©„Äç„Å®ÈÄÅ‰ø°„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ', 
			env
		);
	} catch (error) {
		console.error('Failed to update seafood allergy:', error);
		await sendLineReply(replyToken, 'Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Ç¢„É¨„É´„ÇÆ„ÉºÊÉÖÂ†±„ÅÆÊõ¥Êñ∞„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ', env);
	}
}

async function handleSetupCommand(replyToken: string, env: Env): Promise<void> {
	const setupMessage = `Ë®≠ÂÆö„ÇíÈñãÂßã„Åó„Åæ„Åô„ÄÇ‰ª•‰∏ã„ÅÆÊÉÖÂ†±„ÇíÊïô„Åà„Å¶„Åè„Å†„Åï„ÅÑÔºö

1. „Ç¢„É¨„É´„ÇÆ„ÉºÔºà„ÅÇ„ÇãÂ†¥ÂêàÔºâ
2. Â´å„ÅÑ„Å™È£üÊùê
3. Â•Ω„Åç„Å™ÊñôÁêÜ„Ç∏„É£„É≥„É´

‰æã: "„Ç¢„É¨„É´„ÇÆ„Éº: Âçµ„ÄÅ‰π≥Ë£ΩÂìÅ
Â´å„ÅÑ„Å™È£üÊùê: „Çª„É≠„É™„ÄÅ„Éë„ÇØ„ÉÅ„Éº
Â•Ω„Åç„Å™„Ç∏„É£„É≥„É´: ÂíåÈ£ü„ÄÅ„Ç§„Çø„É™„Ç¢„É≥"

üêü Êµ∑Áî£Áâ©„Ç¢„É¨„É´„ÇÆ„Éº„ÅÆÂ†¥Âêà„ÅØ„Äå„Ç¢„É¨„É´„ÇÆ„Éº Êµ∑Áî£Áâ©„Äç„Å®ÈÄÅ‰ø°„Åó„Å¶„Åè„Å†„Åï„ÅÑ`;

	await sendLineReply(replyToken, setupMessage, env);
}

async function handleMealInput(userId: string, replyToken: string, messageText: string, env: Env): Promise<void> {
	try {
		// Try OpenAI API first
		let mealData = await extractMealData(messageText, env);
		
		if (!mealData) {
			// Fallback to simple parsing if OpenAI fails
			console.log('OpenAI failed, using fallback parsing');
			const stars = messageText.match(/‚≠ê/g) || [];
			const blackStars = messageText.match(/‚òÖ/g) || [];
			const numbers = messageText.match(/[1-5]/g) || [];
			
			let rating = 3; // Default
			if (stars.length > 0) rating = stars.length;
			else if (blackStars.length > 0) rating = blackStars.length;
			else if (numbers.length > 0) rating = parseInt(numbers[0] || '3');
			
			rating = Math.min(Math.max(rating, 1), 5); // Ensure 1-5 range
			
			// Extract dish name (remove stars and common words)
			const dishText = messageText.replace(/[‚≠ê‚òÖ]/g, '').replace(/[0-9]/g, '').trim();
			const dishes = [dishText || 'ÊñôÁêÜ'];
			
			mealData = {
				dishes: dishes,
				rating: rating,
				mood: 'Ê∫ÄË∂≥',
				tags: ['„Åù„ÅÆ‰ªñ']
			};
		}
		
		// Save to database
		await saveMealRecord(userId, mealData, env);
		
		// Send confirmation with OpenAI result indicator
		const aiStatus = mealData.mood !== 'Ê∫ÄË∂≥' || mealData.tags[0] !== '„Åù„ÅÆ‰ªñ' ? 'ü§ñ AIËß£ÊûêÊ∏à„Åø' : 'üìù Á∞°ÊòìËß£Êûê';
		
		await sendLineReply(replyToken, 
			`üçΩÔ∏è È£ü‰∫ã„ÇíË®òÈå≤„Åó„Åæ„Åó„ÅüÔºÅ ${aiStatus}\n\nÊñôÁêÜ: ${mealData.dishes.join(', ')}\nË©ï‰æ°: ${'‚≠ê'.repeat(mealData.rating)}\nÊ∞óÂàÜ: ${mealData.mood}\n„Ç∏„É£„É≥„É´: ${mealData.tags.join(', ')}`, 
			env
		);
		
	} catch (error) {
		console.error('handleMealInput error:', error);
		await sendLineReply(replyToken, 'Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„ÄÇÈ£ü‰∫ãË®òÈå≤„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ', env);
	}
}

/**
 * Áµ±ÂêàÊé®Ëñ¶Èñ¢Êï∞ - „Ç®„Éº„Ç∏„Çß„É≥„ÉàÊ©üËÉΩ„Çí‰ΩøÁî®„Åó„Å¶ÂàùÂõû/ÂÜçÊèêÊ°à„ÇíÁµ±‰∏ÄÂá¶ÁêÜ
 */
async function handleUnifiedRecommendationRequest(
	userId: string,
	replyToken: string,
	messageText: string,
	user: any,
	env: Env,
	ctx: ExecutionContext
): Promise<void> {
	const agent = new RecommendationAgent(env.DB, env.OPENAI_API_KEY, PROMPTS, renderPrompt);
	
	try {
		console.log(`ü§ñ Unified recommendation request from user: ${userId}, message: "${messageText}"`);
		
		// 1. „É°„ÉÉ„Çª„Éº„Ç∏„Åã„ÇâÁõ¥Êé•Ë¶ÅÊ±Ç„Çø„Ç§„Éó„ÇíÂà§ÂÆöÔºàOpenAI APIÂëº„Å≥Âá∫„ÅóÂâäÈô§Ôºâ
		const userRequest = analyzeRequestTypeFromMessage(messageText);
		console.log(`üìä Request type determined: ${userRequest.type}`);
		
		// 2. „Çª„ÉÉ„Ç∑„Éß„É≥ÁÆ°ÁêÜ
		const sessionId = await agent.getCurrentSession(userId);
		console.log(`üìù Current session: ${sessionId}`);
		
		// 3. ÂâçÂõûÊèêÊ°à„ÅÆÂàÜÊûêÔºàÂÜçÊèêÊ°à„ÅÆÂ†¥Âêà„ÅØÂõûÈÅøÊà¶Áï•„ÇíÁ´ã„Å¶„ÇãÔºâ
		const avoidanceStrategy = await agent.analyzePreviousRecommendations(sessionId);
		console.log(`üö´ Avoidance strategy: avoid ${avoidanceStrategy.avoidIngredients.length} ingredients, ${avoidanceStrategy.avoidGenres.length} genres`);
		
		// 4. Âç≥Â∫ß„Å´„É¨„Çπ„Éù„É≥„Çπ
		const responseMessage = userRequest.type === 'general' 
			? 'ü§ñ AI„ÅåÊúÄÈÅ©„Å™ÊñôÁêÜ„ÇíÈÅ∏ÂÆö‰∏≠...\n30Áßí‰ª•ÂÜÖ„Å´„ÅäÈÄÅ„Çä„Åó„Åæ„ÅôÔºÅ'
			: `üéØ ${getRequestTypeEmoji(userRequest.type)} ${getRequestTypeMessage(userRequest.type)}\n30Áßí‰ª•ÂÜÖ„Å´„ÅäÈÄÅ„Çä„Åó„Åæ„ÅôÔºÅ`;
		
		await sendLineReply(replyToken, responseMessage, env);
		
		// 5. „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßÊé®Ëñ¶ÁîüÊàê
		console.log('üîÑ Starting background recommendation generation...');
		ctx.waitUntil(
			generateAndSendRecommendations(userId, sessionId, userRequest, avoidanceStrategy, user, env, agent)
		);
		
	} catch (error) {
		console.error('Unified recommendation failed:', error);
		await sendLineReply(replyToken, 'Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„ÄÇÊé®Ëñ¶„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ', env);
	}
}

/**
 * ÂàùÂõûÊé®Ëñ¶Â∞ÇÁî®Âá¶ÁêÜ - Ë©≥Á¥∞Ë™¨ÊòéÂΩ¢Âºè„ÅßÈ≠ÖÂäõÁöÑ„Å™ÊèêÊ°à
 */
async function handleInitialRecommendation(
	userId: string,
	replyToken: string,
	messageText: string,
	user: any,
	env: Env,
	ctx: ExecutionContext
): Promise<void> {
	try {
		console.log(`üéØ Initial recommendation request from user: ${userId}, message: "${messageText}"`);
		
		// Âç≥Â∫ß„Å´„É¨„Çπ„Éù„É≥„Çπ
		await sendLineReply(replyToken, 'üçΩÔ∏è „ÅÇ„Å™„Åü„Å´„Å¥„Å£„Åü„Çä„ÅÆÂ§ïÈ£ü„ÇíÊèêÊ°à‰∏≠...\n30Áßí‰ª•ÂÜÖ„Å´„ÅäÈÄÅ„Çä„Åó„Åæ„ÅôÔºÅ', env);
		
		// „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßÂàùÂõûÊé®Ëñ¶ÁîüÊàê
		console.log('üîÑ Starting background initial recommendation generation...');
		ctx.waitUntil(
			generateInitialRecommendation(userId, user, env)
		);
		
	} catch (error) {
		console.error('Initial recommendation failed:', error);
		await sendLineReply(replyToken, 'Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„ÄÇÊé®Ëñ¶„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ', env);
	}
}

/**
 * ÂàùÂõûÊé®Ëñ¶ÁîüÊàêÂá¶ÁêÜ
 */
async function generateInitialRecommendation(userId: string, user: any, env: Env): Promise<void> {
	try {
		console.log(`üöÄ generateInitialRecommendation START for user: ${userId}`);
		
		// È£ü‰∫ãÂ±•Ê≠¥ÂèñÂæó
		console.log('üìù Querying meal history...');
		let recentMeals;
		try {
			const mealQueryPromise = env.DB.prepare(`
				SELECT dish, rating, mood, ate_date FROM meals 
				WHERE user_id = ? AND ate_date >= date('now', '-14 days')
				ORDER BY ate_date DESC
			`).bind(userId).all();
			
			const mealTimeoutPromise = new Promise((_, reject) => 
				setTimeout(() => reject(new Error('Meal query timeout after 8s')), 8000)
			);
			
			recentMeals = await Promise.race([mealQueryPromise, mealTimeoutPromise]) as any;
			console.log(`‚úÖ Meal history retrieved: ${(recentMeals as any)?.results?.length || 0} records`);
		} catch (error) {
			console.error('‚ùå Meal history query failed:', error);
			recentMeals = { results: [] };
		}

		// Â§©Ê∞óÊÉÖÂ†±ÂèñÂæó
		console.log('üå§Ô∏è Getting detailed weather data...');
		const weather = await getWeatherData(env);
		console.log(`‚úÖ Weather data: ${weather.temp}¬∞C (‰ΩìÊÑü${weather.feelsLike}¬∞C), ${weather.description}, ${weather.season}`);
		console.log(`üçΩÔ∏è Cooking context: ${weather.cookingContext}`);
		
		// È£ü‰∫ã„Éá„Éº„ÇøÂàÜÊûê
		const mealHistory = recentMeals.results || [];
		const recentDishes = mealHistory.slice(0, 7).map((m: any) => m.dish);
		const highRatedMeals = mealHistory.filter((m: any) => m.rating >= 4).map((m: any) => m.dish);
		
		// „Éó„É≠„É≥„Éó„ÉàÂ§âÊï∞Ê∫ñÂÇôÔºàÂº∑Âåñ„Åï„Çå„ÅüÂ§©Ê∞óÊÉÖÂ†±„ÇíÂê´„ÇÄÔºâ
		const variables = {
			recentMeals: recentDishes.slice(0, 5).join(', ') || 'ÊÉÖÂ†±„Å™„Åó',
			preferredDishes: highRatedMeals.slice(0, 3).join(', ') || 'ÊÉÖÂ†±„Å™„Åó',
			allergies: user?.allergies || '„Å™„Åó',
			dislikes: user?.dislikes || '„Å™„Åó',
			temperature: weather.temp.toString(),
			weather: `${weather.description}Ôºà‰ΩìÊÑüÊ∞óÊ∏©${weather.feelsLike}¬∞C„ÄÅÊπøÂ∫¶${weather.humidity}%„ÄÅ${weather.season}„ÄÅ${weather.cookingContext}Ôºâ`
		};
		
		// Êñ∞„Åó„ÅÑ„Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥„Éó„É≠„É≥„Éó„Éà„Çí‰ΩøÁî®
		console.log('üìù Rendering initial recommendation prompt...');
		const prompt = await loadAndRenderMarkdownPrompt('initial-recommendation', variables);
		console.log('‚úÖ Prompt rendered');

		// OpenAI APIÂëº„Å≥Âá∫„Åó
		console.log('ü§ñ Calling OpenAI API for initial recommendation...');
		const response = await fetch('https://api.openai.com/v1/chat/completions', {
			method: 'POST',
			headers: {
				'Authorization': `Bearer ${env.OPENAI_API_KEY}`,
				'Content-Type': 'application/json',
			},
			body: JSON.stringify({
				model: 'gpt-4o-mini',
				messages: [{ role: 'user', content: prompt }],
				max_tokens: 1000,
				temperature: 0.9,
			}),
		});

		if (!response.ok) {
			throw new Error(`OpenAI API error: ${response.status}`);
		}

		const data = await response.json() as any;
		const recommendationText = data.choices[0].message.content;
		
		console.log('‚úÖ Initial recommendation generated');

		// ÊñôÁêÜÂêç„ÇíÊäΩÂá∫„Åó„Å¶„Éá„Éº„Çø„Éô„Éº„Çπ„Å´‰øùÂ≠ò
		await extractAndSaveInitialRecommendations(userId, recommendationText, env);

		// „ÇØ„Ç§„ÉÉ„ÇØ„É™„Éó„É©„Ç§„Éú„Çø„É≥‰ªò„Åç„ÅßÈÄÅ‰ø°
		await sendLineMessageWithQuickReply(
			userId, 
			recommendationText, 
			createRecommendationQuickReply(),
			env
		);
		
		console.log('‚úÖ Initial recommendation sent to user');
		
	} catch (error) {
		console.error('Initial recommendation generation failed:', error);
		// „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „Ç∑„É≥„Éó„É´„Å™„É°„ÉÉ„Çª„Éº„Ç∏
		await sendLineMessage(userId, 'Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„ÄÇÊé®Ëñ¶„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÂÜçÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ', env);
	}
}

/**
 * ÂàùÂõûÊèêÊ°à„Åã„ÇâÊñôÁêÜÂêç„ÇíÊäΩÂá∫„Åó„Å¶„Éá„Éº„Çø„Éô„Éº„Çπ„Å´‰øùÂ≠òÔºà„Çà„ÇäÂº∑Âõ∫„Å™ÊäΩÂá∫„É≠„Ç∏„ÉÉ„ÇØÔºâ
 */
async function extractAndSaveInitialRecommendations(userId: string, recommendationText: string, env: Env): Promise<void> {
	try {
		console.log('üîç Extracting dish names from initial recommendation...');
		console.log('üìÑ Full recommendation text:', recommendationText);
		
		let dishNames: string[] = [];
		
		// Method 1: Ë§áÊï∞„ÅÆÊ≠£Ë¶èË°®Áèæ„Éë„Çø„Éº„É≥„ÅßÁõ¥Êé•ÊäΩÂá∫
		const patterns = [
			// „Éë„Çø„Éº„É≥1: "1. **ÊñôÁêÜÂêç** - Ë™¨Êòé"
			/\d+\.\s*\*\*([^*]+)\*\*/g,
			// „Éë„Çø„Éº„É≥2: "1. ÊñôÁêÜÂêç - Ë™¨Êòé"  
			/\d+\.\s*([^-\n]+?)(?:\s*[-„Éº]|$)/g,
			// „Éë„Çø„Éº„É≥3: "**ÊñôÁêÜÂêç**"
			/\*\*([^*]+)\*\*/g,
			// „Éë„Çø„Éº„É≥4: "1. ÊñôÁêÜÂêç"ÔºàË°åÊú´„Åæ„ÅßÔºâ
			/\d+\.\s*([^\n]+)/g
		];
		
		for (const pattern of patterns) {
			const matches = recommendationText.match(pattern);
			if (matches && matches.length >= 3) {
				dishNames = matches.slice(0, 3).map(m => {
					return m.replace(/\*\*/g, '')
							.replace(/^\d+\.\s*/, '')
							.replace(/\s*[-„Éº].*$/, '')
							.trim();
				}).filter(name => name.length > 1 && name.length < 30);
				
				if (dishNames.length >= 3) {
					console.log(`‚úÖ Pattern extraction successful with pattern: ${pattern}`, dishNames);
					break;
				}
			}
		}
		
		// Method 2: OpenAI „Å´„Çà„ÇãÊäΩÂá∫Ôºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ
		if (dishNames.length < 3) {
			console.log('ü§ñ Trying OpenAI extraction as fallback...');
			try {
				const extractPromise = fetch('https://api.openai.com/v1/chat/completions', {
					method: 'POST',
					headers: {
						'Authorization': `Bearer ${env.OPENAI_API_KEY}`,
						'Content-Type': 'application/json',
					},
					body: JSON.stringify({
						model: 'gpt-4o-mini',
						messages: [
							{ 
								role: 'system', 
								content: '„ÅÇ„Å™„Åü„ÅØÊñôÁêÜÂêçÊäΩÂá∫„ÅÆÂ∞ÇÈñÄÂÆ∂„Åß„Åô„ÄÇ„ÉÜ„Ç≠„Çπ„Éà„Åã„ÇâÊ≠£Á¢∫„Å´3„Å§„ÅÆÊñôÁêÜÂêç„ÇíÊäΩÂá∫„Åó„ÄÅJSONÈÖçÂàó„ÅßËøî„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÊñôÁêÜÂêç„ÅÆ„Åø„Åß„ÄÅË™¨Êòé„ÇÑË£ÖÈ£æ„ÅØÂê´„ÇÅ„Å™„ÅÑ„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ' 
							},
							{ 
								role: 'user', 
								content: `‰ª•‰∏ã„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Åã„Çâ1Áï™ÁõÆ„ÄÅ2Áï™ÁõÆ„ÄÅ3Áï™ÁõÆ„ÅÆÊñôÁêÜÂêç„ÇíÊäΩÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÊñôÁêÜÂêç„ÅÆ„Åø„ÇíÂê´„ÇÄJSONÈÖçÂàó„ÅßÂõûÁ≠î„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö\n\n${recommendationText}` 
							}
						],
						max_tokens: 150,
						temperature: 0.1,
					}),
				});

				const extractTimeout = new Promise((_, reject) => 
					setTimeout(() => reject(new Error('OpenAI extraction timeout')), 8000)
				);

				const response = await Promise.race([extractPromise, extractTimeout]) as Response;

				if (response.ok) {
					const data = await response.json() as any;
					const extracted = JSON.parse(data.choices[0].message.content);
					if (Array.isArray(extracted) && extracted.length >= 3) {
						dishNames = extracted.slice(0, 3);
						console.log('‚úÖ OpenAI extraction successful:', dishNames);
					}
				}
			} catch (aiError) {
				console.error('OpenAI extraction failed:', aiError);
			}
		}
		
		// Method 3: ÊúÄÁµÇ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ - ÂàÜÊûêÁöÑÊäΩÂá∫
		if (dishNames.length < 3) {
			console.log('üîß Using analytical fallback extraction...');
			const lines = recommendationText.split('\n');
			const candidateLines = lines.filter(line => 
				/^\d+\./.test(line.trim()) && line.length > 5 && line.length < 200
			);
			
			if (candidateLines.length >= 3) {
				dishNames = candidateLines.slice(0, 3).map(line => {
					// „Çà„ÇäË©≥Á¥∞„Å™„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
					return line.replace(/^\d+\.\s*/, '')
							   .replace(/\*\*/g, '')
							   .replace(/[-„Éº].*$/, '')
							   .replace(/^„Äê.*?„Äë/, '')
							   .replace(/\s+$/, '')
							   .trim();
				}).filter(name => name.length > 1);
				
				console.log('üîß Analytical extraction result:', dishNames);
			}
		}
		
		// ÊúÄÁµÇÁöÑ„Å™„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
		if (dishNames.length < 3) {
			console.log('‚ö†Ô∏è All extraction methods failed, using generic names');
			dishNames = ['Êú¨Êó•„ÅÆÊñôÁêÜ1', 'Êú¨Êó•„ÅÆÊñôÁêÜ2', 'Êú¨Êó•„ÅÆÊñôÁêÜ3'];
		}

		console.log('üçΩÔ∏è Final extracted dish names:', dishNames);

		// „Çª„ÉÉ„Ç∑„Éß„É≥„Çí‰ΩúÊàê„Åæ„Åü„ÅØÂèñÂæó
		const agent = new RecommendationAgent(env.DB, env.OPENAI_API_KEY, PROMPTS, renderPrompt);
		const sessionId = await agent.startNewSession(userId);

		// ÂêÑÊñôÁêÜ„Çírecommended_dishes„ÉÜ„Éº„Éñ„É´„Å´‰øùÂ≠ò
		for (let i = 0; i < dishNames.length; i++) {
			const dishName = dishNames[i];
			try {
				const savePromise = env.DB.prepare(`
					INSERT INTO recommended_dishes (session_id, dish_name, genre, main_ingredient, cooking_method, recommendation_order, recommended_at)
					VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
				`).bind(sessionId, dishName, 'Êú™ÂàÜÈ°û', '‰∏çÊòé', '‰∏çÊòé', i + 1).run();

				const saveTimeout = new Promise((_, reject) => 
					setTimeout(() => reject(new Error('Save timeout after 5s')), 5000)
				);

				await Promise.race([savePromise, saveTimeout]);
				console.log(`‚úÖ Saved dish ${i + 1}: ${dishName}`);
			} catch (saveError) {
				console.error(`Failed to save dish ${i + 1}:`, saveError);
			}
		}

		console.log('‚úÖ All initial recommendations saved to database');

	} catch (error) {
		console.error('Failed to extract and save initial recommendations:', error);
		// „Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Å¶„ÇÇ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅØÁ∂ôÁ∂ö
	}
}

/**
 * „É°„ÉÉ„Çª„Éº„Ç∏„Åã„ÇâË¶ÅÊ±Ç„Çø„Ç§„Éó„ÇíÁõ¥Êé•Âà§ÂÆöÔºàOpenAI API‰∏çË¶ÅÔºâ
 */
function analyzeRequestTypeFromMessage(message: string): UserRequest {
	const lowerMessage = message.toLowerCase();
	
	// ÂêÑ„Çø„Ç§„Éó„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ„Éë„Çø„Éº„É≥
	const patterns = {
		light: ['„ÅÇ„Å£„Åï„Çä', '„Åï„Å£„Å±„Çä', 'ËªΩ„ÅÑ', '„É©„Ç§„Éà', 'Ê∑°ÁôΩ'],
		hearty: ['„Åå„Å£„Å§„Çä', '„Åó„Å£„Åã„Çä', '„Éú„É™„É•„Éº„É†', 'Ê∫ÄËÖπ', 'Èáç„ÅÑ', '„Åì„Å£„Å¶„Çä'],
		different: ['ÈÅï„ÅÜ', 'Âà•„ÅÆ', '‰ªñ„ÅÆ', 'Â§â„Åà„Çã', 'Âà•„Çå„Åü„ÅÑ', '‰ºº„Å¶„Å™„ÅÑ'],
		diverse: ['Â§öÊßò', '„Éê„É™„Ç®„Éº„Ç∑„Éß„É≥', 'ÈÅ∏ÊäûËÇ¢', 'Á®ÆÈ°û']
	};
	
	// „Éë„Çø„Éº„É≥„Éû„ÉÉ„ÉÅ„É≥„Ç∞
	for (const [type, keywords] of Object.entries(patterns)) {
		if (keywords.some(keyword => lowerMessage.includes(keyword))) {
			return {
				type: type as UserRequest['type'],
				originalMessage: message,
				timestamp: new Date()
			};
		}
	}
	
	// „Éá„Éï„Ç©„É´„Éà„ÅØ general
	return {
		type: 'general',
		originalMessage: message,
		timestamp: new Date()
	};
}

/**
 * Ë¶ÅÊ±Ç„Çø„Ç§„Éó„Å´Âøú„Åò„ÅüÁµµÊñáÂ≠ó„ÇíÂèñÂæó
 */
function getRequestTypeEmoji(type: UserRequest['type']): string {
	const emojis = {
		diverse: 'üé≤',
		light: 'ü•ó', 
		hearty: 'üçñ',
		different: '‚ú®',
		general: 'üçΩÔ∏è'
	};
	return emojis[type] || emojis.general;
}

/**
 * Ë¶ÅÊ±Ç„Çø„Ç§„Éó„Å´Âøú„Åò„Åü„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂèñÂæó
 */
function getRequestTypeMessage(type: UserRequest['type']): string {
	const messages = {
		diverse: 'Â§öÊßò„Å™ÊñôÁêÜ„ÇíÂàÜÊûê‰∏≠...',
		light: '„ÅÇ„Å£„Åï„Çä„Åó„ÅüÊñôÁêÜ„ÇíÂàÜÊûê‰∏≠...',
		hearty: '„Åå„Å£„Å§„Çä„Åó„ÅüÊñôÁêÜ„ÇíÂàÜÊûê‰∏≠...',
		different: 'ÂâçÂõû„Å®„ÅØÈÅï„ÅÜÊñôÁêÜ„ÇíÂàÜÊûê‰∏≠...',
		general: 'ÊúÄÈÅ©„Å™ÊñôÁêÜ„ÇíÂàÜÊûê‰∏≠...'
	};
	return messages[type] || messages.general;
}

// ÊóßÈñ¢Êï∞ÔºàÂæåÊñπ‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅ‰∏ÄÊôÇÁöÑ„Å´‰øùÊåÅÔºâ
async function handleRecommendationRequest(userId: string, replyToken: string, user: any, env: Env, ctx: ExecutionContext): Promise<void> {
	// Áµ±ÂêàÈñ¢Êï∞„Å´„É™„ÉÄ„Ç§„É¨„ÇØ„Éà
	console.log('‚ö†Ô∏è Legacy function called, redirecting to unified handler...');
	await handleUnifiedRecommendationRequest(userId, replyToken, '„Åä„Åô„Åô„ÇÅ', user, env, ctx);
}

/**
 * „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßÊé®Ëñ¶„ÇíÁîüÊàê„Åó„Å¶„É¶„Éº„Ç∂„Éº„Å´ÈÄÅ‰ø°
 */
async function generateAndSendRecommendations(
	userId: string,
	sessionId: string,
	userRequest: UserRequest,
	avoidanceStrategy: any,
	user: any,
	env: Env,
	agent: RecommendationAgent
): Promise<void> {
	try {
		console.log(`üîÑ generateAndSendRecommendations START for user: ${userId}, session: ${sessionId}`);
		
		// 1. „Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÊßãÁØâ
		const context = await buildRecommendationContext(userId, user, userRequest, avoidanceStrategy, env);
		
		// 2. „Ç®„Éº„Ç∏„Çß„É≥„ÉàÊ©üËÉΩ„ÅßÂ§öÊßòÊÄß„ÇíÁ¢∫‰øù„Åó„ÅüÊé®Ëñ¶ÁîüÊàê
		const recommendations = await agent.generateDiverseRecommendations(context);
		console.log(`‚úÖ Generated ${recommendations.length} recommendations: ${recommendations.map(r => r.dishName).join(', ')}`);
		
		// 3. „Çª„ÉÉ„Ç∑„Éß„É≥Êõ¥Êñ∞ÔºàÊèêÊ°àÂ±•Ê≠¥„ÇíË®òÈå≤Ôºâ
		await agent.updateSession(sessionId, recommendations, context);
		console.log(`üìù Session updated with new recommendations`);
		
		// 4. ÂÜçÊèêÊ°à„Åß„ÅØÊó¢„Å´Ë©≥Á¥∞„Å™Êé®Ëñ¶Êñá„ÅåÁîüÊàê„Åï„Çå„Å¶„ÅÑ„Çã„ÅÆ„Åß„Åù„ÅÆ„Åæ„Åæ‰ΩøÁî®
		const detailedResponse = recommendations[0].userFeedback || '„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü';
		const quickReplyButtons = createRecommendationQuickReply();
		await sendLineMessageWithQuickReply(userId, detailedResponse, quickReplyButtons, env);
		console.log(`‚úÖ Recommendations sent to user ${userId}`);
		
	} catch (error) {
		console.error('Background recommendation generation failed:', error);
		await sendLineMessage(userId, 'Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„ÄÇÊé®Ëñ¶„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Åó„Å∞„Çâ„ÅèÂæå„Å´ÂÜçÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ', env);
	}
}

// ÊóßBackground async functionÔºàÂæåÊñπ‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅ‰∏ÄÊôÇÁöÑ„Å´‰øùÊåÅÔºâ
async function generateRecommendationsAsync(userId: string, user: any, env: Env): Promise<void> {
	try {
		console.log(`üîÑ generateRecommendationsAsync START for user: ${userId} (legacy function)`);
		const recommendations = await generateRecommendations(userId, user, env);
		console.log('üì§ Sending recommendations to user...');
		await sendLineMessage(userId, recommendations, env);
		console.log('‚úÖ generateRecommendationsAsync COMPLETE');
	} catch (error) {
		console.error('‚ùå generateRecommendationsAsync error:', error);
		await sendLineMessage(userId, 'ü§ñ AIÂàÜÊûêÂÆå‰∫Ü„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü\n\nüìù Êú¨Êó•„ÅÆÁ∞°ÊòìÊèêÊ°àÔºö\n1. **Ë±öËÇâ„Å®ÈáéËèúÁÇí„ÇÅ** - ÊâãËªΩ„ÅßÊ†ÑÈ§ä„Éê„É©„É≥„Çπ‚óé\n2. **ÈÆ≠„ÅÆ„É†„Éã„Ç®„É´** - „ÅÇ„Å£„Åï„ÇäÁæéÂë≥„Åó„ÅÑ\n3. **„Ç´„É¨„Éº„É©„Ç§„Çπ** - ÂÆöÁï™„ÅßÂÆâÂøÉ\n\nË©≥„Åó„ÅÑ„É¨„Ç∑„Éî„ÅåÂøÖË¶Å„Åß„Åó„Åü„Çâ„Äå1„Äç„Å™„Å©„ÅÆÁï™Âè∑„ÇíÈÄÅ‰ø°„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ', env);
		console.log('üì§ Fallback message sent');
	}
}

async function handleRecipeRequest(userId: string, replyToken: string, messageText: string, env: Env, ctx: ExecutionContext): Promise<void> {
	try {
		console.log(`üç≥ Recipe request from user ${userId}: "${messageText}"`);
		
		// Âç≥Â∫ß„Å´„É¨„Çπ„Éù„É≥„Çπ
		await sendLineReply(replyToken, 'üç≥ „É¨„Ç∑„Éî„ÇíÊ∫ñÂÇô‰∏≠„Åß„Åô...\n30Áßí‰ª•ÂÜÖ„Å´„ÅäÈÄÅ„Çä„Åó„Åæ„ÅôÔºÅ', env);
		
		let dishName = '';
	
		if (messageText.match(/^[1-3]$/)) {
			// User selected a number, get from recent recommendations
			try {
				const selectedIndex = parseInt(messageText) - 1; // 0-indexed
				
				// Get the latest session for this user with timeout
				const agent = new RecommendationAgent(env.DB, env.OPENAI_API_KEY, PROMPTS, renderPrompt);
				
				const sessionPromise = agent.getCurrentSession(userId);
				const sessionTimeout = new Promise((_, reject) => 
					setTimeout(() => reject(new Error('Session query timeout after 5s')), 5000)
				);
				
				const sessionId = await Promise.race([sessionPromise, sessionTimeout]) as string;
				
				// Get recent recommendations from this session with timeout
				const recommendationPromise = env.DB.prepare(`
					SELECT dish_name FROM recommended_dishes 
					WHERE session_id = ? 
					ORDER BY recommendation_order ASC, recommended_at DESC 
					LIMIT 3
				`).bind(sessionId).all();
				
				const recommendationTimeout = new Promise((_, reject) => 
					setTimeout(() => reject(new Error('Recommendation query timeout after 5s')), 5000)
				);
				
				const recentRecommendations = await Promise.race([recommendationPromise, recommendationTimeout]) as any;
				
				const dishes = (recentRecommendations.results as any[]) || [];
				if (dishes.length > selectedIndex) {
					dishName = dishes[selectedIndex].dish_name;
				} else {
					dishName = `ÂÄôË£ú${messageText}`; // Fallback
				}
				
			} catch (error) {
				console.error('Failed to get recommended dish:', error);
				dishName = `ÂÄôË£ú${messageText}`; // Fallback
			}
		} else {
			// Extract dish name from message using OpenAI
			const extractedDish = await extractDishFromMessage(messageText, env);
			dishName = extractedDish || 'ÈÅ∏Êäû„Åï„Çå„ÅüÊñôÁêÜ';
		}
		
		console.log(`üç≥ Generating recipe for: ${dishName}`);
		
		// „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„Åß„É¨„Ç∑„ÉîÁîüÊàê
		ctx.waitUntil(
			generateAndSendRecipe(userId, dishName, env)
		);
		
		
	} catch (error) {
		console.error('‚ùå Recipe request failed:', error);
		await sendLineMessage(userId, 'Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„ÄÇ„É¨„Ç∑„Éî„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ', env);
	}
}

/**
 * „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„Åß„É¨„Ç∑„Éî„ÇíÁîüÊàê„Åó„Å¶„É¶„Éº„Ç∂„Éº„Å´ÈÄÅ‰ø°
 */
async function generateAndSendRecipe(userId: string, dishName: string, env: Env): Promise<void> {
	try {
		console.log(`üç≥ Background recipe generation for: ${dishName}`);
		const recipe = await generateRecipe(dishName, env);
		await sendLineMessage(userId, recipe, env);
		
		// Save as decided meal with timeout protection
		try {
			const today = new Date().toISOString().split('T')[0];
			const savePromise = env.DB.prepare(`
				INSERT INTO meals (user_id, ate_date, dish, decided)
				VALUES (?, ?, ?, 1)
			`).bind(userId, today, dishName).run();
			
			const saveTimeout = new Promise((_, reject) => 
				setTimeout(() => reject(new Error('Save meal timeout after 5s')), 5000)
			);
			
			await Promise.race([savePromise, saveTimeout]);
			console.log(`‚úÖ Recipe sent and meal recorded: ${dishName}`);
		} catch (saveError) {
			console.error('Failed to save meal record:', saveError);
		}
		
	} catch (error) {
		console.error('Background recipe generation failed:', error);
		await sendLineMessage(userId, `Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„ÄÇ${dishName}„ÅÆ„É¨„Ç∑„ÉîÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ`, env);
	}
}

/**
 * Êé®Ëñ¶„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÇíÊßãÁØâ
 */
async function buildRecommendationContext(
	userId: string, 
	user: any, 
	userRequest: UserRequest, 
	avoidanceStrategy: any, 
	env: Env
): Promise<RecommendationContext> {
	// ÊúÄËøë„ÅÆÈ£ü‰∫ãÂ±•Ê≠¥„ÇíÂèñÂæó
	let recentMeals = [];
	let preferredDishes = [];
	try {
		const mealResult = await env.DB.prepare(`
			SELECT dish, rating, mood, ate_date 
			FROM meals 
			WHERE user_id = ? AND ate_date >= date('now', '-14 days')
			ORDER BY ate_date DESC 
			LIMIT 10
		`).bind(userId).all();
		
		recentMeals = (mealResult.results as any[]) || [];
		// È´òË©ï‰æ°ÊñôÁêÜ„ÇíÂàÜÊûêÔºàÂàùÂõûÊèêÊ°à„Å®Âêå„Åò„É≠„Ç∏„ÉÉ„ÇØÔºâ
		preferredDishes = recentMeals.filter((m: any) => m.rating >= 4).map((m: any) => m.dish);
		console.log(`üìä Retrieved ${recentMeals.length} recent meals, ${preferredDishes.length} preferred dishes for user ${userId}`);
	} catch (error) {
		console.error('Failed to get recent meals:', error);
	}
	
	// Â§©Ê∞óÊÉÖÂ†±„ÇíÂèñÂæó
	let weather = undefined;
	try {
		weather = await getWeatherData(env);
		console.log(`üå§Ô∏è Weather data retrieved: ${weather.temp}¬∞C (‰ΩìÊÑü${weather.feelsLike}¬∞C), ${weather.description}, ${weather.season}`);
	} catch (error) {
		console.error('Failed to get weather:', error);
	}
	
	return {
		user: {
			id: userId,
			allergies: user.allergies,
			dislikes: user.dislikes
		},
		recentMeals,
		preferredDishes,
		previousRecommendations: [], // „Çª„ÉÉ„Ç∑„Éß„É≥„Åã„ÇâÂèñÂæó„ÅåÂøÖË¶Å
		userRequest,
		weather,
		avoidanceStrategy
	};
}

/**
 * Ë©≥Á¥∞„Å™Êé®Ëñ¶„ÉÜ„Ç≠„Çπ„Éà„ÇíÁîüÊàêÔºàÂàùÂõû„Å®Âêå„ÅòË©≥Á¥∞ÂΩ¢ÂºèÔºâ
 */
async function generateDetailedRecommendationText(recommendations: RecommendedDish[], userRequest: UserRequest, env: Env): Promise<string> {
	try {
		// Êé®Ëñ¶ÊÉÖÂ†±„ÇíÊï¥ÁêÜ
		const dishNames = recommendations.map(r => r.dishName).join(', ');
		const genres = recommendations.map(r => r.genre).join(', ');
		const ingredients = recommendations.map(r => r.mainIngredient).join(', ');
		
		const typeMessages = {
			diverse: 'üé≤ Â§öÊßò„Å™ÊñôÁêÜ„Çí„ÅîÊèêÊ°à„Åó„Åæ„Åô',
			light: 'ü•ó „ÅÇ„Å£„Åï„Çä„Åó„ÅüÊñôÁêÜ„Çí„ÅîÊèêÊ°à„Åó„Åæ„Åô',
			hearty: 'üçñ „Åå„Å£„Å§„Çä„Åó„ÅüÊñôÁêÜ„Çí„ÅîÊèêÊ°à„Åó„Åæ„Åô', 
			different: '‚ú® ÂâçÂõû„Å®„ÅØÈÅï„ÅÜÊñôÁêÜ„Çí„ÅîÊèêÊ°à„Åó„Åæ„Åô',
			general: 'üçΩÔ∏è „Åä„Åô„Åô„ÇÅ„ÅÆÊñôÁêÜ„Çí„ÅîÊèêÊ°à„Åó„Åæ„Åô'
		};
		
		const header = typeMessages[userRequest.type] || typeMessages.general;
		
		// OpenAI„ÅßË©≥Á¥∞Ë™¨Êòé„ÇíÁîüÊàê
		const prompt = `‰ª•‰∏ã„ÅÆ3„Å§„ÅÆÊñôÁêÜ„Å´„Å§„ÅÑ„Å¶„ÄÅ„Åù„Çå„Åû„ÇåÈ≠ÖÂäõÁöÑ„ÅßË©≥Á¥∞„Å™Ë™¨ÊòéÊñá„Çí‰ΩúÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

ÊñôÁêÜÂêç: ${dishNames}
„Ç∏„É£„É≥„É´: ${genres}
‰∏ªË¶ÅÈ£üÊùê: ${ingredients}
Ë¶ÅÊ±Ç„Çø„Ç§„Éó: ${userRequest.type}

ÂêÑÊñôÁêÜ„Å´„Å§„ÅÑ„Å¶‰ª•‰∏ã„ÅÆÂΩ¢Âºè„ÅßÂá∫Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö
1. **[ÊñôÁêÜÂêç]** - [ÈÅ∏„Çì„Å†ÁêÜÁî±„Å®È≠ÖÂäõÁöÑ„Å™Ë™¨ÊòéÔºà30ÊñáÂ≠óÁ®ãÂ∫¶Ôºâ]
2. **[ÊñôÁêÜÂêç]** - [ÈÅ∏„Çì„Å†ÁêÜÁî±„Å®È≠ÖÂäõÁöÑ„Å™Ë™¨ÊòéÔºà30ÊñáÂ≠óÁ®ãÂ∫¶Ôºâ]
3. **[ÊñôÁêÜÂêç]** - [ÈÅ∏„Çì„Å†ÁêÜÁî±„Å®È≠ÖÂäõÁöÑ„Å™Ë™¨ÊòéÔºà30ÊñáÂ≠óÁ®ãÂ∫¶Ôºâ]

Ë™¨Êòé„ÅØÂÖ∑‰ΩìÁöÑ„ÅßÈ£üÊ¨≤„Çí„Åù„Åù„ÇãÂÜÖÂÆπ„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`;

		const response = await fetch('https://api.openai.com/v1/chat/completions', {
			method: 'POST',
			headers: {
				'Authorization': `Bearer ${env.OPENAI_API_KEY}`,
				'Content-Type': 'application/json',
			},
			body: JSON.stringify({
				model: 'gpt-4o-mini',
				messages: [{ role: 'user', content: prompt }],
				max_tokens: 400,
				temperature: 0.7,
			}),
		});

		if (!response.ok) {
			throw new Error(`OpenAI API error: ${response.status}`);
		}

		const data = await response.json() as any;
		const detailedList = data.choices[0].message.content;
		
		return `${header}\n\n${detailedList}\n\nÁï™Âè∑„ÇíÈÅ∏Êäû„Åô„Çã„Å®„É¨„Ç∑„Éî„ÇíÁ¢∫Ë™ç„Åß„Åç„Åæ„ÅôÔºÅ`;
		
	} catch (error) {
		console.error('Failed to generate detailed recommendation text:', error);
		// „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „Ç∑„É≥„Éó„É´ÂΩ¢Âºè
		return formatDetailedRecommendationResponse(recommendations, userRequest);
	}
}

/**
 * Ë©≥Á¥∞„Å™Êé®Ëñ¶„É¨„Çπ„Éù„É≥„Çπ„Çí„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÁî®Ôºâ
 */
function formatDetailedRecommendationResponse(recommendations: RecommendedDish[], userRequest: UserRequest): string {
	const typeHeaders = {
		diverse: 'üé≤ **Â§öÊßò„Å™ÊñôÁêÜ„Çí„ÅîÊèêÊ°à„Åó„Åæ„Åô**',
		light: 'ü•ó **„ÅÇ„Å£„Åï„Çä„Åó„ÅüÊñôÁêÜ„Çí„ÅîÊèêÊ°à„Åó„Åæ„Åô**',
		hearty: 'üçñ **„Åå„Å£„Å§„Çä„Åó„ÅüÊñôÁêÜ„Çí„ÅîÊèêÊ°à„Åó„Åæ„Åô**', 
		different: '‚ú® **ÂâçÂõû„Å®„ÅØÈÅï„ÅÜÊñôÁêÜ„Çí„ÅîÊèêÊ°à„Åó„Åæ„Åô**',
		general: 'üçΩÔ∏è **‰ªäÊó•„ÅÆ„Åä„Åô„Åô„ÇÅÂ§ïÈ£ü**'
	};
	
	const header = typeHeaders[userRequest.type] || typeHeaders.general;
	
	const dishList = recommendations.map((dish, index) => 
		`${index + 1}. **${dish.dishName}** - ${dish.userFeedback || `${dish.genre}„ÅÆ${dish.mainIngredient}„Çí‰Ωø„Å£„Åü${dish.cookingMethod}ÊñôÁêÜ`}`
	).join('\n\n');
	
	return `${header}\n\n${dishList}\n\nÁï™Âè∑„ÇíÈÅ∏Êäû„Åô„Çã„Å®„É¨„Ç∑„Éî„ÇíÁ¢∫Ë™ç„Åß„Åç„Åæ„ÅôÔºÅ`;
}

/**
 * „ÇØ„Ç§„ÉÉ„ÇØ„É™„Éó„É©„Ç§‰ªò„Åç„ÅßLINE„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÈÄÅ‰ø°
 */
async function sendLineMessageWithQuickReply(userId: string, message: string, quickReplyItems: any[], env: Env): Promise<void> {
	try {
		const response = await fetch('https://api.line.me/v2/bot/message/push', {
			method: 'POST',
			headers: {
				'Authorization': `Bearer ${env.LINE_CHANNEL_ACCESS_TOKEN}`,
				'Content-Type': 'application/json',
			},
			body: JSON.stringify({
				to: userId,
				messages: [
					{
						type: 'text',
						text: message,
						quickReply: {
							items: quickReplyItems
						}
					}
				]
			})
		});

		if (!response.ok) {
			throw new Error(`LINE API error: ${response.status} ${response.statusText}`);
		}
		
		console.log('‚úÖ LINE message with quick reply sent successfully');
	} catch (error) {
		console.error('Failed to send LINE message with quick reply:', error);
		// „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ÈÄöÂ∏∏„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„Å®„Åó„Å¶ÈÄÅ‰ø°
		await sendLineMessage(userId, message, env);
	}
}

/**
 * Êé®Ëñ¶Âæå„ÅÆ„ÇØ„Ç§„ÉÉ„ÇØ„É™„Éó„É©„Ç§„Éú„Çø„É≥„Çí‰ΩúÊàê
 */
function createRecommendationQuickReply(): any[] {
	return [
		{
			type: 'action',
			action: {
				type: 'message',
				label: '„É¨„Ç∑„Éî‚ë†',
				text: '1'
			}
		},
		{
			type: 'action',
			action: {
				type: 'message',
				label: '„É¨„Ç∑„Éî‚ë°',
				text: '2'
			}
		},
		{
			type: 'action',
			action: {
				type: 'message',
				label: '„É¨„Ç∑„Éî‚ë¢',
				text: '3'
			}
		},
		{
			type: 'action',
			action: {
				type: 'message',
				label: '‰ªñ„ÅÆÊèêÊ°à„ÇíË¶ã„Çã',
				text: '‰ªñ„ÅÆÊèêÊ°à„ÇíË¶ã„Çã'
			}
		}
	];
}

/**
 * „Ç∑„É≥„Éó„É´„Å™Êé®Ëñ¶„É¨„Çπ„Éù„É≥„Çπ„Çí„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÔºàÊóßÂΩ¢ÂºèÔºâ
 */
function formatRecommendationResponse(recommendations: string[], userRequest: UserRequest): string {
	const typeMessages = {
		diverse: 'üé≤ Â§öÊßò„Å™ÊñôÁêÜ„Çí„ÅîÊèêÊ°à„Åó„Åæ„Åô',
		light: 'ü•ó „ÅÇ„Å£„Åï„Çä„Åó„ÅüÊñôÁêÜ„Çí„ÅîÊèêÊ°à„Åó„Åæ„Åô',
		hearty: 'üçñ „Åå„Å£„Å§„Çä„Åó„ÅüÊñôÁêÜ„Çí„ÅîÊèêÊ°à„Åó„Åæ„Åô', 
		different: '‚ú® ÂâçÂõû„Å®„ÅØÈÅï„ÅÜÊñôÁêÜ„Çí„ÅîÊèêÊ°à„Åó„Åæ„Åô',
		general: 'üçΩÔ∏è „Åä„Åô„Åô„ÇÅ„ÅÆÊñôÁêÜ„Çí„ÅîÊèêÊ°à„Åó„Åæ„Åô'
	};
	
	const header = typeMessages[userRequest.type] || typeMessages.general;
	const dishList = recommendations.map((dish, index) => `${index + 1}. ${dish}`).join('\n');
	
	return `${header}\n\n${dishList}\n\nÁï™Âè∑„ÇíÈÅ∏Êäû„Åô„Çã„Å®„É¨„Ç∑„Éî„ÇíÁ¢∫Ë™ç„Åß„Åç„Åæ„ÅôÔºÅ`;
}

async function handleGeneralMessage(replyToken: string, messageText: string, env: Env): Promise<void> {
	// „Ç¢„É¨„É´„ÇÆ„Éº„ÇÑË®≠ÂÆöÈñ¢ÈÄ£„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØË®≠ÂÆöÊ°àÂÜÖ
	if (messageText.includes('„Ç¢„É¨„É´„ÇÆ„Éº') || messageText.includes('Ë®≠ÂÆö') || messageText.includes('Â´å„ÅÑ') || messageText.includes('Ëã¶Êâã')) {
		await sendLineReply(replyToken, 
			'‚öôÔ∏è Ë®≠ÂÆö„Å´Èñ¢„Åô„Çã„ÅäÂïè„ÅÑÂêà„Çè„Åõ„Åß„Åô„Å≠ÔºÅ\n\n' +
			'‚Ä¢ ÂàùÊúüË®≠ÂÆöÔºö„Äå/setup„Äç\n' +
			'‚Ä¢ Êµ∑Áî£Áâ©„Ç¢„É¨„É´„ÇÆ„ÉºÔºö„Äå„Ç¢„É¨„É´„ÇÆ„Éº Êµ∑Áî£Áâ©„Äç\n' +
			'‚Ä¢ Â´å„ÅÑ„Å™È£üÊùêÔºö„ÄåÂ´å„ÅÑ„Å™È£üÊùê „Åù„ÇâË±Ü„ÄÅ„Ç§„É≥„Ç≤„É≥Ë±Ü„Äç\n' +
			'‚Ä¢ ‰Ωø„ÅÑÊñπÁ¢∫Ë™çÔºö„Äå‰Ωø„ÅÑÊñπ„Äç\n\n' +
			'„Å®ÈÄÅ‰ø°„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
			env
		);
	} else {
		// ‰∏ÄËà¨„É°„ÉÉ„Çª„Éº„Ç∏„Å∏„ÅÆÂøúÁ≠î
		await sendLineReply(replyToken, 
			'„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂèó„ÅëÂèñ„Çä„Åæ„Åó„Åü„ÄÇ\n\n' +
			'üìù È£ü‰∫ãË®òÈå≤Ôºö‚≠ê „ÅßË©ï‰æ°„Å®‰∏ÄÁ∑í„Å´ÊäïÁ®ø\n' +
			'üçΩÔ∏è ÊñôÁêÜÊèêÊ°àÔºö„Äå„Åä„Åô„Åô„ÇÅÊïô„Åà„Å¶„Äç\n' +
			'‚ùì ‰Ωø„ÅÑÊñπÔºö„Äå‰Ωø„ÅÑÊñπ„Äç\n\n' +
			'„ÅäÊ∞óËªΩ„Å´„ÅäÂ£∞„Åã„Åë„Åè„Å†„Åï„ÅÑÔºÅ',
			env
		);
	}
}

async function sendDailyRecommendations(env: Env): Promise<void> {
	console.log('üïê sendDailyRecommendations START');
	
	try {
		const users = await getAllUsers(env);
		console.log(`üë• Found ${users.length} total users`);
		
		const invitedUsers = users.filter(user => user.invited);
		console.log(`‚úÖ Found ${invitedUsers.length} invited users`);
		
		if (invitedUsers.length === 0) {
			console.log('‚ö†Ô∏è No invited users found - skipping daily recommendations');
			return;
		}
		
		for (const user of invitedUsers) {
			try {
				console.log(`üì§ Sending recommendations to user: ${user.id}`);
				const recommendations = await generateRecommendations(user.id, user, env);
				await sendLineMessage(user.id, recommendations, env);
				console.log(`‚úÖ Successfully sent recommendations to ${user.id}`);
			} catch (error) {
				console.error(`‚ùå Failed to send recommendations to ${user.id}:`, error);
			}
		}
		
		console.log('üïê sendDailyRecommendations COMPLETE');
	} catch (error) {
		console.error('‚ùå sendDailyRecommendations FAILED:', error);
	}
}

// Database functions with timeout protection
async function getUser(userId: string, env: Env): Promise<any> {
	try {
		console.log(`üóÑÔ∏è getUser START for userId: ${userId}`);
		console.log('üîó Preparing D1 query...');
		
		// Add timeout protection (10 seconds)
		const queryPromise = env.DB.prepare('SELECT * FROM users WHERE id = ?').bind(userId).first();
		const timeoutPromise = new Promise((_, reject) => 
			setTimeout(() => reject(new Error('D1 query timeout after 10s')), 10000)
		);
		
		console.log('‚ö° Executing D1 query with timeout...');
		const result = await Promise.race([queryPromise, timeoutPromise]);
		console.log(`‚úÖ getUser COMPLETE - result: ${result ? 'found' : 'not found'}`);
		return result;
	} catch (error) {
		console.error(`‚ùå getUser ERROR for ${userId}:`, error);
		// Return null if query fails to allow fallback behavior
		return null;
	}
}

async function getAllUsers(env: Env): Promise<any[]> {
	const result = await env.DB.prepare('SELECT * FROM users WHERE invited = 1').all();
	return result.results || [];
}

async function saveMealRecord(userId: string, mealData: any, env: Env): Promise<void> {
	const today = new Date().toISOString().split('T')[0];
	
	for (const dish of mealData.dishes) {
		await env.DB.prepare(`
			INSERT INTO meals (user_id, ate_date, dish, tags, rating, mood, decided)
			VALUES (?, ?, ?, ?, ?, ?, 1)
		`).bind(
			userId,
			today,
			dish,
			JSON.stringify(mealData.tags || []),
			mealData.rating,
			mealData.mood
		).run();
	}
}

// OpenAI functions
async function extractMealData(text: string, env: Env): Promise<any> {
	const prompt = `Extract meal information from this text: "${text}"
	
Return a JSON object with:
- dishes: array of dish names
- rating: number 1-5 (from stars)
- mood: mood keyword
- tags: array of cuisine tags

Example: {"dishes": ["Ë±ö„Éê„É©Â§ßÊ†π", "Âë≥ÂôåÊ±Å"], "rating": 3, "mood": "Ê∫ÄË∂≥", "tags": ["ÂíåÈ£ü"]}`;

	try {
		const response = await fetch('https://api.openai.com/v1/chat/completions', {
			method: 'POST',
			headers: {
				'Authorization': `Bearer ${env.OPENAI_API_KEY}`,
				'Content-Type': 'application/json',
			},
			body: JSON.stringify({
				model: 'gpt-4o-mini',
				messages: [
					{ role: 'system', content: 'Extract dishes, rating (‚òÖ1-5), mood keyword. Return pure JSON.' },
					{ role: 'user', content: prompt }
				],
				temperature: 0.1,
			}),
		});

		const data = await response.json() as any;
		if (!data.choices?.[0]?.message?.content) {
			throw new Error('Invalid OpenAI response');
		}
		return JSON.parse(data.choices[0].message.content);
	} catch (error) {
		console.error('OpenAI extraction error:', error);
		return null;
	}
}

async function generateRecommendations(userId: string, user: any, env: Env): Promise<string> {
	try {
		console.log(`üöÄ generateRecommendations START for user: ${userId}`);
		
		// Skip redundant user data retrieval - use passed user data
		console.log('üìä Using existing user data...');
		if (!user) {
			console.log('‚ö†Ô∏è No user data provided, proceeding without user preferences');
		} else {
			console.log('‚úÖ User data available');
		}
		
		// Get focused meal history (restored with ctx.waitUntil() fix)
		console.log('üìù Querying meal history with timeout protection...');
		let recentMeals;
		try {
			const mealQueryPromise = env.DB.prepare(`
				SELECT dish, rating, mood, ate_date FROM meals 
				WHERE user_id = ? AND ate_date >= date('now', '-14 days')
				ORDER BY ate_date DESC
			`).bind(userId).all();
			
			const mealTimeoutPromise = new Promise((_, reject) => 
				setTimeout(() => reject(new Error('Meal query timeout after 8s')), 8000)
			);
			
			recentMeals = await Promise.race([mealQueryPromise, mealTimeoutPromise]) as any;
			console.log(`‚úÖ Meal history retrieved: ${(recentMeals as any)?.results?.length || 0} records`);
		} catch (error) {
			console.error('‚ùå Meal history query failed:', error);
			// Fallback to mock data if D1 query fails
			recentMeals = {
				results: [
					{ dish: '„Éè„É≥„Éê„Éº„Ç∞', rating: 4, mood: 'Ê∫ÄË∂≥', ate_date: '2025-06-05' },
					{ dish: '„Ç´„É¨„Éº„É©„Ç§„Çπ', rating: 3, mood: 'ÊôÆÈÄö', ate_date: '2025-06-04' },
					{ dish: 'ÁÑº„ÅçÈ≠ö', rating: 5, mood: 'ÁæéÂë≥„Åó„ÅÑ', ate_date: '2025-06-03' }
				]
			};
			console.log('‚ö†Ô∏è Using mock meal history as fallback');
		}
		
		// Original query (commented out for testing)
		/*
		let recentMeals;
		try {
			const mealQueryPromise = env.DB.prepare(`
				SELECT dish, rating, mood, ate_date FROM meals 
				WHERE user_id = ? AND ate_date >= date('now', '-14 days')
				ORDER BY ate_date DESC
			`).bind(userId).all();
			
			const mealTimeoutPromise = new Promise((_, reject) => 
				setTimeout(() => reject(new Error('Meal query timeout after 8s')), 8000)
			);
			
			recentMeals = await Promise.race([mealQueryPromise, mealTimeoutPromise]) as any;
			console.log(`‚úÖ Meal history retrieved: ${(recentMeals as any)?.results?.length || 0} records`);
		} catch (error) {
			console.error('‚ùå Meal history query failed:', error);
			recentMeals = { results: [] }; // Fallback to empty results
			console.log('‚ö†Ô∏è Using empty meal history as fallback');
		}
		*/

		// Get weather data
		console.log('üå§Ô∏è Getting Tokyo weather data...');
		const weather = await getWeatherData(env);
		console.log(`‚úÖ Weather data ready: ${weather.temp}¬∞C, ${weather.description}`);
		
		// Analyze meal patterns
		console.log('üß† Analyzing meal patterns...');
		const mealHistory = recentMeals.results || [];
		const recentDishes = mealHistory.slice(0, 7).map((m: any) => m.dish);
		console.log(`‚úÖ Analysis complete - ${recentDishes.length} recent dishes`);
		
		// Enhanced personalized prompt
		console.log('üìù Preparing personalized OpenAI prompt...');
		const recentList = recentDishes.slice(0, 5).join(', ');
		
		// Analyze user preferences from meal history
		const highRatedMeals = mealHistory.filter((m: any) => m.rating >= 4).map((m: any) => m.dish);
		const preferredDishes = highRatedMeals.slice(0, 3).join(', ');
		
		// Build comprehensive prompt
		const prompt = `„ÅÇ„Å™„Åü„ÅØÂ§ïÈ£ü„É¨„Ç≥„É°„É≥„ÉâÂ∞ÇÈñÄAI„Åß„Åô„ÄÇ‰ª•‰∏ã„ÅÆÊÉÖÂ†±„ÇíÂü∫„Å´„ÄÅ„Éê„É©„Ç®„ÉÜ„Ç£„Å´ÂØå„Çì„Å†3„Å§„ÅÆÂ§ïÈ£ü„ÇíÊèêÊ°à„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

„Äê„É¶„Éº„Ç∂„ÉºÊÉÖÂ†±„Äë
- ÊúÄËøëÈ£ü„Åπ„ÅüÊñôÁêÜÔºàÈÅø„Åë„ÇãÔºâ: ${recentList}
- È´òË©ï‰æ°„Å†„Å£„ÅüÊñôÁêÜÔºàÂèÇËÄÉ„Å´Ôºâ: ${preferredDishes || 'ÊÉÖÂ†±„Å™„Åó'}
- „Ç¢„É¨„É´„ÇÆ„Éº: ${user?.allergies || 'ÊÉÖÂ†±„Å™„Åó'}
- Â´å„ÅÑ„Å™È£üÊùê: ${user?.dislikes || 'ÊÉÖÂ†±„Å™„Åó'}

„ÄêÁí∞Â¢ÉÊÉÖÂ†±„Äë
- ‰ªäÊó•„ÅÆÊ∞óÊ∏©: ${weather.temp}¬∞C
- Â§©Ê∞ó: ${weather.description}

„ÄêÊèêÊ°àË¶Å‰ª∂„Äë
- 3„Å§„ÅÆÊñôÁêÜ„ÅØÁï∞„Å™„Çã„Ç∏„É£„É≥„É´ÔºàÂíåÈ£ü„ÉªÊ¥ãÈ£ü„Éª‰∏≠ËèØ„Å™„Å©Ôºâ„Å´„Åô„Çã
- „Ç¢„É¨„É´„ÇÆ„Éº„Å®Â´å„ÅÑ„Å™È£üÊùê„ÅØÁµ∂ÂØæ„Å´ÈÅø„Åë„Çã
- Ê∞óÊ∏©„Å´ÈÅ©„Åó„ÅüÊñôÁêÜ„ÇíÈÅ∏„Å∂
- „Éê„É™„Ç®„Éº„Ç∑„Éß„É≥Ë±ä„Åã„Å™ÊèêÊ°à„Çí„Åô„Çã

„Éï„Ç©„Éº„Éû„ÉÉ„Éà:
1. **[ÊñôÁêÜÂêç]** - [ÈÅ∏„Çì„Å†ÁêÜÁî±]
2. **[ÊñôÁêÜÂêç]** - [ÈÅ∏„Çì„Å†ÁêÜÁî±]  
3. **[ÊñôÁêÜÂêç]** - [ÈÅ∏„Çì„Å†ÁêÜÁî±]

Ë©≥„Åó„ÅÑ„É¨„Ç∑„Éî„ÅåÂøÖË¶Å„Å™Â†¥Âêà„ÅØÁï™Âè∑„ÇíÈÄÅ‰ø°„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`;
		console.log('‚úÖ Prompt ready');

		console.log('ü§ñ Calling OpenAI API...');
		
		const response = await fetch('https://api.openai.com/v1/chat/completions', {
			method: 'POST',
			headers: {
				'Authorization': `Bearer ${env.OPENAI_API_KEY}`,
				'Content-Type': 'application/json',
			},
			body: JSON.stringify({
				model: 'gpt-4o-mini',
				messages: [
					{ 
						role: 'system', 
						content: '„ÅÇ„Å™„Åü„ÅØÊñôÁêÜ„Å®„Ç∞„É´„É°„Å´Ë©≥„Åó„ÅÑÂ§ïÈ£ü„É¨„Ç≥„É°„É≥„ÉâÂ∞ÇÈñÄAI„Åß„Åô„ÄÇ„É¶„Éº„Ç∂„Éº„ÅÆÂ•Ω„Åø„ÄÅ„Ç¢„É¨„É´„ÇÆ„Éº„ÄÅÈ£ü‰∫ãÂ±•Ê≠¥„ÄÅÂ§©Ê∞ó„ÇíËÄÉÊÖÆ„Åó„Å¶„Éë„Éº„ÇΩ„Éä„É©„Ç§„Ç∫„Åï„Çå„ÅüÊèêÊ°à„Çí„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÊØéÂõûÁï∞„Å™„Çã„Éê„É©„Ç®„ÉÜ„Ç£Ë±ä„Åã„Å™ÊñôÁêÜ„ÇíÊèêÊ°à„Åô„Çã„Åì„Å®„ÅåÈáçË¶Å„Åß„Åô„ÄÇ' 
					},
					{ role: 'user', content: prompt }
				],
				temperature: 0.7,
				max_tokens: 300,
			}),
		});
		console.log('‚úÖ OpenAI API response received!');
		console.log(`‚úÖ OpenAI API response received (status: ${response.status})`);

		// Check if response is ok before parsing
		if (!response.ok) {
			const errorText = await response.text();
			console.error(`‚ùå OpenAI API error: ${response.status} - ${errorText}`);
			throw new Error(`OpenAI API error: ${response.status}`);
		}
		
		const data = await response.json() as any;
		console.log('üìã Parsing OpenAI response...');
		console.log(`üìä Response data keys: ${Object.keys(data).join(', ')}`);
		
		if (!data.choices?.[0]?.message?.content) {
			console.error('‚ùå Invalid OpenAI response structure:', JSON.stringify(data));
			throw new Error('Invalid OpenAI response structure');
		}
		
		console.log('üéâ generateRecommendations COMPLETE');
		return data.choices[0].message.content;
		
	} catch (error) {
		console.error('Recommendation generation error:', error);
		return `üçΩÔ∏è „É¨„Ç≥„É°„É≥„ÉâÁîüÊàê„Ç®„É©„Éº

Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„ÄÇAIÂàÜÊûê‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ

üìù Á∑äÊÄ•ÊèêÊ°àÔºö
1. **ÂÜ∑„Åó„ÇÉ„Å∂„Çµ„É©„ÉÄ** - Êöë„ÅÑÊó•„Å´„Åï„Å£„Å±„Çä
2. **„ÉÅ„Ç≠„É≥ÂçóËõÆ** - „Éú„É™„É•„Éº„É†Ê∫ÄÁÇπ
3. **ÂÜ∑Ë£Ω„Éë„Çπ„Çø** - Â§è„Çâ„Åó„ÅèËªΩ„ÇÑ„Åã

ÂÜçÂ∫¶„Äå„Åä„Åô„Åô„ÇÅÊïô„Åà„Å¶„Äç„Å®ÈÄÅ‰ø°„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`;
	}
}

// LINE Messaging API
async function sendLineMessage(userId: string, message: string, env: Env): Promise<void> {
	try {
		const response = await fetch('https://api.line.me/v2/bot/message/push', {
			method: 'POST',
			headers: {
				'Authorization': `Bearer ${env.LINE_CHANNEL_ACCESS_TOKEN}`,
				'Content-Type': 'application/json',
			},
			body: JSON.stringify({
				to: userId,
				messages: [
					{
						type: 'text',
						text: message
					}
				]
			}),
		});
		
		if (!response.ok) {
			throw new Error(`LINE API error: ${response.status} ${response.statusText}`);
		}
	} catch (error) {
		console.error('LINE message send error:', error);
	}
}

async function sendLineReply(replyToken: string, message: string, env: Env): Promise<void> {
	try {
		const response = await fetch('https://api.line.me/v2/bot/message/reply', {
			method: 'POST',
			headers: {
				'Authorization': `Bearer ${env.LINE_CHANNEL_ACCESS_TOKEN}`,
				'Content-Type': 'application/json',
			},
			body: JSON.stringify({
				replyToken: replyToken,
				messages: [
					{
						type: 'text',
						text: message
					}
				]
			}),
		});
		
		if (!response.ok) {
			const errorText = await response.text();
			throw new Error(`LINE API error: ${response.status} ${response.statusText} - ${errorText}`);
		}
	} catch (error) {
		console.error('LINE reply send error:', error);
	}
}

// Weather API
async function getWeatherData(env: Env): Promise<any> {
	try {
		// Default to Tokyo coordinates
		const response = await fetch(
			`https://api.openweathermap.org/data/2.5/weather?lat=35.6762&lon=139.6503&appid=${env.OPENWEATHER_API_KEY}&units=metric&lang=ja`
		);
		const data = await response.json() as any;
		
		// Ë©≥Á¥∞„Å™Â§©Ê∞óÊÉÖÂ†±„ÇíÂèñÂæó
		const temp = Math.round(data.main.temp);
		const feelsLike = Math.round(data.main.feels_like);
		const humidity = data.main.humidity;
		const description = data.weather[0].description;
		const windSpeed = Math.round(data.wind?.speed || 0);
		
		// Â≠£ÁØÄÊÉÖÂ†±„ÇíËøΩÂä†
		const season = getCurrentSeason();
		
		// ÊñôÁêÜÊé®Ëñ¶Áî®„ÅÆÂ§©Ê∞ó„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÇíÁîüÊàê
		const cookingContext = generateCookingWeatherContext(temp, description, season, humidity, feelsLike);
		
		return {
			temp,
			feelsLike,
			description,
			humidity,
			windSpeed,
			season,
			cookingContext
		};
	} catch (error) {
		console.error('Weather API error:', error);
		return { 
			temp: 20, 
			feelsLike: 20,
			description: 'Êô¥„Çå', 
			humidity: 60,
			windSpeed: 0,
			season: getCurrentSeason(),
			cookingContext: 'Âø´ÈÅ©„Å™Ê∞óÂÄô„Åß„ÄÅ„Å©„Çì„Å™ÊñôÁêÜ„Åß„ÇÇÊ•Ω„Åó„ÇÅ„ÇãÊó•„Åß„Åô„ÄÇ'
		};
	}
}

/**
 * ÁèæÂú®„ÅÆÂ≠£ÁØÄ„ÇíÂèñÂæó
 */
function getCurrentSeason(): string {
	const month = new Date().getMonth() + 1; // 0-based to 1-based
	
	if (month >= 3 && month <= 5) return 'Êò•';
	if (month >= 6 && month <= 8) return 'Â§è'; 
	if (month >= 9 && month <= 11) return 'Áßã';
	return 'ÂÜ¨';
}

/**
 * ÊñôÁêÜÊé®Ëñ¶Áî®„ÅÆÂ§©Ê∞ó„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÇíÁîüÊàê
 */
function generateCookingWeatherContext(temp: number, description: string, season: string, humidity: number, feelsLike: number): string {
	let context = `${season}„ÅÆÂ≠£ÁØÄ„ÄÅ`;
	
	// Ê∞óÊ∏©„Å´„Çà„ÇãÊé®Ëñ¶
	if (temp <= 5) {
		context += 'Â§ßÂ§âÂØí„ÅÑÊó•ÔºàÊ∏©„Åã„ÅÑÊñôÁêÜ„Éª„Çπ„Éº„Éó„ÉªÈçãÁâ©„Åå„Åä„Åô„Åô„ÇÅÔºâ';
	} else if (temp <= 15) {
		context += 'ÂØí„ÅÑÊó•ÔºàÊ∏©„Åã„ÅÑÊñôÁêÜ„ÉªÁÖÆËæº„ÅøÊñôÁêÜ„Åå„Åä„Åô„Åô„ÇÅÔºâ';
	} else if (temp <= 25) {
		context += 'ÈÅé„Åî„Åó„ÇÑ„Åô„ÅÑÊó•ÔºàÊßò„ÄÖ„Å™ÊñôÁêÜ„ÅåÊ•Ω„Åó„ÇÅ„ÇãÔºâ';
	} else if (temp <= 30) {
		context += 'Êöñ„Åã„ÅÑÊó•Ôºà„Åï„Å£„Å±„Çä„Åó„ÅüÊñôÁêÜ„Åå„Åä„Åô„Åô„ÇÅÔºâ';
	} else {
		context += 'Êöë„ÅÑÊó•ÔºàÂÜ∑„Åü„ÅÑÊñôÁêÜ„Éª„ÅÇ„Å£„Åï„ÇäÁ≥ª„Åå„Åä„Åô„Åô„ÇÅÔºâ';
	}
	
	// Â§©Ê∞ó„Å´„Çà„ÇãËøΩÂä†ÊÉÖÂ†±
	if (description.includes('Èõ®')) {
		context += '„ÄÅÈõ®„ÅÆÊó•„ÅßÊ∏©„Åã„ÅÑÂÆ§ÂÜÖÊñôÁêÜ„ÅåËâØ„ÅÑ';
	} else if (description.includes('Èõ™')) {
		context += '„ÄÅÈõ™„ÅÆÊó•„Åß‰Ωì„ÇíÊ∏©„ÇÅ„ÇãÊñôÁêÜ„ÅåËâØ„ÅÑ';
	} else if (description.includes('Êõá')) {
		context += '„ÄÅÊõá„Çä„ÅßËêΩ„Å°ÁùÄ„ÅÑ„ÅüÈõ∞Âõ≤Ê∞ó';
	} else if (description.includes('Êô¥')) {
		context += '„ÄÅÊô¥„Çå„Å¶Ê∞óÂàÜ„ÇÇÊòé„Çã„ÅÑ';
	}
	
	// ÊπøÂ∫¶„Å´„Çà„ÇãËøΩÂä†
	if (humidity > 80) {
		context += '„ÄÅÊπøÂ∫¶„ÅåÈ´ò„Åè„Åï„Å£„Å±„ÇäÁ≥ª„ÅåËâØ„ÅÑ';
	} else if (humidity < 30) {
		context += '„ÄÅ‰πæÁá•„Åó„Å¶„ÅÑ„Çã„ÅÆ„ÅßÊ∞¥ÂàÜ„ÅÆÂ§ö„ÅÑÊñôÁêÜ„ÅåËâØ„ÅÑ';
	}
	
	return context;
}

async function extractDishFromMessage(text: string, env: Env): Promise<string | null> {
	try {
		const response = await fetch('https://api.openai.com/v1/chat/completions', {
			method: 'POST',
			headers: {
				'Authorization': `Bearer ${env.OPENAI_API_KEY}`,
				'Content-Type': 'application/json',
			},
			body: JSON.stringify({
				model: 'gpt-4o-mini',
				messages: [
					{ role: 'system', content: 'Extract the dish name from user message. Return only the dish name.' },
					{ role: 'user', content: `Extract dish name from: "${text}"` }
				],
				temperature: 0.1,
			}),
		});

		const data = await response.json() as any;
		return data.choices[0].message.content.trim();
	} catch (error) {
		console.error('Dish extraction error:', error);
		return null;
	}
}

async function generateRecipe(dishName: string, env: Env): Promise<string> {
	try {
		console.log(`üç≥ Generating recipe for: ${dishName}`);
		
		const recipePromise = fetch('https://api.openai.com/v1/chat/completions', {
			method: 'POST',
			headers: {
				'Authorization': `Bearer ${env.OPENAI_API_KEY}`,
				'Content-Type': 'application/json',
			},
			body: JSON.stringify({
				model: 'gpt-4o-mini',
				messages: [
					{ role: 'system', content: 'Return ingredients list (name, qty) & numbered steps for requested dish, for 4 people.' },
					{ role: 'user', content: `${dishName}„ÅÆ4‰∫∫ÂàÜ„ÅÆ„É¨„Ç∑„Éî„ÇíÊïô„Åà„Å¶„ÄÇÊùêÊñô„Å®ÊâãÈ†Ü„ÇíÂàÜ„Åë„Å¶Êõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ` }
				],
				temperature: 0.3,
			}),
		});

		const recipeTimeout = new Promise((_, reject) => 
			setTimeout(() => reject(new Error('Recipe generation timeout after 20s')), 20000)
		);

		const response = await Promise.race([recipePromise, recipeTimeout]) as Response;

		if (!response.ok) {
			throw new Error(`OpenAI API error: ${response.status}`);
		}

		const data = await response.json() as any;
		const recipe = data.choices[0].message.content;
		
		console.log('‚úÖ Recipe generated, generating shopping list...');
		
		// Generate shopping list with timeout
		let shoppingList = '';
		try {
			shoppingList = await generateShoppingList(recipe, env);
		} catch (error) {
			console.error('Shopping list generation failed:', error);
			shoppingList = 'Ë≤∑„ÅÑÁâ©„É™„Çπ„Éà„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ';
		}
		
		return `üìù ${dishName}„ÅÆ„É¨„Ç∑„Éî\n\n${recipe}\n\nüõí Ë≤∑„ÅÑÁâ©„É™„Çπ„Éà\n${shoppingList}`;
	} catch (error) {
		console.error('Recipe generation error:', error);
		return `Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„ÄÇ${dishName}„ÅÆ„É¨„Ç∑„ÉîÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ\n\nÁ∞°Êòì„É¨„Ç∑„Éî:\nÂü∫Êú¨ÁöÑ„Å™${dishName}„ÅÆ‰Ωú„ÇäÊñπ„Çí„ÅäË™ø„Åπ„ÅÑ„Åü„Å†„Åè„Åã„ÄÅ„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ`;
	}
}

async function generateShoppingList(recipe: string, env: Env): Promise<string> {
	try {
		const shoppingPromise = fetch('https://api.openai.com/v1/chat/completions', {
			method: 'POST',
			headers: {
				'Authorization': `Bearer ${env.OPENAI_API_KEY}`,
				'Content-Type': 'application/json',
			},
			body: JSON.stringify({
				model: 'gpt-4o-mini',
				messages: [
					{ role: 'system', content: 'Extract shopping list from recipe. Return as bullet points with quantities.' },
					{ role: 'user', content: `„Åì„ÅÆ„É¨„Ç∑„Éî„Åã„ÇâË≤∑„ÅÑÁâ©„É™„Çπ„Éà„Çí‰ΩúÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö\n${recipe}` }
				],
				temperature: 0.1,
			}),
		});

		const shoppingTimeout = new Promise((_, reject) => 
			setTimeout(() => reject(new Error('Shopping list timeout after 15s')), 15000)
		);

		const response = await Promise.race([shoppingPromise, shoppingTimeout]) as Response;

		if (!response.ok) {
			throw new Error(`OpenAI API error: ${response.status}`);
		}

		const data = await response.json() as any;
		return data.choices[0].message.content;
	} catch (error) {
		console.error('Shopping list generation error:', error);
		return 'Ë≤∑„ÅÑÁâ©„É™„Çπ„Éà„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„É¨„Ç∑„Éî„ÇíÂèÇËÄÉ„Å´ÂøÖË¶Å„Å™ÊùêÊñô„Çí„ÅîÁ¢∫Ë™ç„Åè„Å†„Åï„ÅÑ„ÄÇ';
	}
}

async function verifyLineSignature(body: string, signature: string, channelSecret: string): Promise<boolean> {
	try {
		const crypto = (globalThis as any).crypto;
		const encoder = new TextEncoder();
		const secretKey = encoder.encode(channelSecret);
		const bodyBytes = encoder.encode(body);
		
		// Create HMAC-SHA256 signature
		const key = await crypto.subtle.importKey(
			'raw',
			secretKey,
			{ name: 'HMAC', hash: 'SHA-256' },
			false,
			['sign']
		);
		
		const signatureBuffer = await crypto.subtle.sign('HMAC', key, bodyBytes);
		
		// Convert to base64
		const base64Signature = btoa(String.fromCharCode(...new Uint8Array(signatureBuffer)));
		
		const receivedSignature = signature.replace('sha256=', '');
		return base64Signature === receivedSignature;
	} catch (error) {
		console.error('Signature verification error:', error);
		return false;
	}
}

async function createUser(userId: string, env: Env): Promise<void> {
	await env.DB.prepare(`
		INSERT INTO users (id, invited, created_at)
		VALUES (?, 0, CURRENT_TIMESTAMP)
	`).bind(userId).run();
}

async function inviteUser(userId: string, env: Env): Promise<void> {
	await env.DB.prepare(`
		UPDATE users SET invited = 1 WHERE id = ?
	`).bind(userId).run();
}